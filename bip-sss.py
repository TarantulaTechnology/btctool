#!/usr/bin/python
#
# Shamir's Secret Sharing proposed BIP.
# Reference implementation.
# This program is hereby placed in the public domain.

import hashlib
import binascii
import random

# Content type byte value.
CTB_BASE58      = 19

# Galois field GF(2^8)
class GF:
    INFTY = 255         # special case representing log(0)

    def __init__(self, poly):
        # generate exp and log lookup tables
        self.log = [ self.INFTY ] * 256 # allocate log table
        self.exp = [ 0 ] * 256          # allocate exp table
        # compute b = 2**i in GF sequentially for all i from 0 to 254
        b = 1   # 2**0
        for i in range(255):
            self.log[b] = i
            self.exp[i] = b
            # compute next power for the next loop iteration
            b <<= 1
            if b & 0x100:
                b ^= poly

        # check that this polynomial really generates a GF
        assert b == 1
        assert self.log[0] == self.INFTY
        assert self.exp[self.INFTY] == 0

    # arithmetic in the vector space over GF(2^8)
    # where vectors are represented as sequences of GF elements (bytes)

    def vadd(self, u, v):
        assert len(u) == len(v)
        # this is simply bytewise xor, regardless of the poly
        return map(int.__xor__, u, v)

    # multiply vector v by scalar a
    def vmul(self, v, a):
        u = bytearray(len(v))   # allocate the result vector u
        if a == 0:
            return u
        a = self.log[a]
        for i in range(len(v)):
            if v[i] != 0:
                # product's log is the sum of multiplicands' logs, modulo 255
                lp = (self.log[v[i]] + a) % 255
                u[i] = self.exp[lp]
        return u

    # divide scalar a by scalar b
    def div(self, a, b):
        if b == 0:
            raise ZeroDivisionError("division by zero in GF(2^8)")
        if a == 0:
            return 0
        # proper modulus of negative numbers is important!
        lp = (self.log[a] - self.log[b]) % 255
        return self.exp[lp]

# Hash: double SHA-256
def double_sha(seq):
    h = hashlib.sha256(bytearray(seq)).digest()
    h = hashlib.sha256(h).digest()
    return h

base58map = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

# Base-58 encoding of a sequence of bytes
def base58(x):
    # convert sequence to a long number
    n = reduce(lambda a, b: a << 8 | b, x)
    e = ""
    while n:
        e = base58map[n % 58] + e
        n /= 58
    # prepend ones for each zero byte
    for i in x:
        if i:
            break
        e = "1" + e

    return e

def base58check(x):
    x = bytearray(x)
    return base58(x + double_sha(x)[:4])

def unbase58(e):
    n = 0l
    for c in e:
        n = n * 58 + base58map.index(c)
    b = []
    while n:
        b = [int(n & 255)] + b
        n >>= 8
    for c in e:
        if c != '1':
            break
        b = [0] + b

    x = bytearray(b[:-4])
    assert double_sha(x)[:4] == bytearray(b[-4:])

    return x

# Generate coefficients with a deterministic algorithm using SHA-256.
def sha_coeff(secret, m):
    secret = bytearray(secret)
    res = [secret]
    for i in range(1, m):
        j = 0
        coeff = ""
        while len(coeff) < len(secret):
            coeff += hashlib.sha256(secret + bytearray([i, j])).digest()
            j += 1
        res += [bytearray(coeff[:len(secret)])]
    return res

# Generate random coefficients.
def random_coeff(secret, m):
    coeff = bytearray(secret)
    res = [coeff]
    rnd = random.SystemRandom()
    for i in range(1, m):
        coeff = [ int(rnd.getrandbits(8)) for k in range(len(coeff)) ]
        res += [coeff]
    return res

# Compute one share.
# x is between 1 and 255, typically the share's number starting from 1.
# coeff is generated by sha_coeff or random_coeff; len(coeff) == M,
# where M is the number of shares required to reveal the secret.
def make_share(gf, x, coeff):
    s = coeff[0]                # cumulative share (value of the polynomial)
    xpow = 1                    # current power of x, starting from x^0
    for c in coeff[1:]:
        [xpow] = gf.vmul([xpow], x)
        s = gf.vadd(s, gf.vmul(c, xpow))
    return s

# Combine M shares and compute the secret.
# Shares are given as a sequence of pairs (x, share).
def combine(gf, shares):
    m = len(shares)                     # number of shares = M = degree+1
    xxx = [ x for x, s in shares ]      # share indices
    n = [1]                             # preparing Lagrange numerator
    for x in xxx:
        n = gf.vmul(n, x)
    [n] = n
    a = bytearray(len(shares[0][1]))    # cumulative secret: a0
    for x, share in shares:
        lc = gf.div(n, x)               # cumulative Lagrange coefficient
        for xj in xxx:
            if xj != x:
                lc = gf.div(lc, xj ^ x) # lc = lc / (xj - x) in GF
        a = gf.vadd(a, gf.vmul(share, lc))
    return a

# Encode a share.
# Parameters:
#   content_type:       one of CTB_xxx values, currently always 19
#   share_set_id:       two bytes identifying this set of shares
def encode(share, content_type, m, share_set_id):
    x, share = share

    assert x >= 1 and x <= 16
    assert m >= 1 and m <= 16

    return "SSS-" + base58check([content_type]
                              + list(share_set_id)
                              + [(m-1) << 4 | (x-1)]
                              + list(share))

# Decode a share.
def decode(text):
    assert text[:4] == "SSS-"

    b = unbase58(text[4:])
    content_type = b[0]
    share_set_id = b[1:3]
    m = (b[3] >> 4) + 1
    x = (b[3] & 0xF) + 1
    share = x, b[4:]

    #print content_types[content_type], "ID", binascii.hexlify(share_set_id) + ",",
    #print "M = %d, x = %d" % (m, x)

    return share, m, share_set_id, content_type

# Make an M-of-N set of shares
def make_set(gf, content_type, m, n, secret, gen_coeff = sha_coeff, set_id = None):
    assert n >= 1 and n <= 16
    assert m >= 1 and m <= n

    if not set_id:
        set_id = double_sha(secret)[:2]
    coeff = gen_coeff(secret, m)

    shares = [ (x, bytearray(make_share(gf, x, coeff))) for x in range(1, n+1) ]
    enc = [ encode(share, content_type, m, set_id) for share in shares ]

    print "%d of %d encoding; share set ID %s; share length %d" % (m, n,
            binascii.hexlify(set_id), len(enc[0]))

    return shares, enc

def make_and_check(gf, content_type, m, n, secret, gen_coeff = sha_coeff, set_id = None):
    shares, enc = make_set(gf, content_type, m, n, secret, gen_coeff, set_id)
    set_id = None
    for i, enc_share in enumerate(enc):
        share, dec_m, dec_id, dec_type = decode(enc_share)
        print "  Share %2d: %s" % (share[0], enc_share)
        # check that all IDs in this set are the same
        assert set_id == None or dec_id == set_id
        set_id = dec_id
        # check that everything else is good
        assert dec_m == m and dec_type == content_type
        assert share == shares[i]
    xxx = range(n)
    random.shuffle(xxx)
    combined = combine(gf, [ shares[i] for i in xxx[:m] ])
    assert combined == secret

def make_secret(content_type,
                length = None,          # will be random if not given
                data = None,            # will be random if not given
                is_private_key = False,
                compressed = True,      # for regular private key
                testnet = False):
    print
    if length == None and data == None:
        if is_private_key:
            length = 32
        else:
            length = random.randint(0, 80)
    if data == None:
        data = [ int(random.getrandbits(8)) for i in range(length) ]
    if is_private_key:
        # encode in WIF (SIPA format)
        data = [ { False: 0x80, True: 0xef } [testnet] ] + data + \
                { True: [1], False: [] } [compressed]
        print "Private key:", base58check(data)
    if data:
        text = binascii.hexlify(bytearray(data))
    else:
        text = "(empty)"
    print "Secret: " + text
    return list(data)

def sss_test(gf, q, m):
    secret = [ int(random.getrandbits(8)) for k in range(q) ]
    coeff = random_coeff(secret, m)
    xxx = range(1, 256)
    random.shuffle(xxx)
    print "SSS test: length %d, M = %d:" % (q, m),
    shares = [ (x, make_share(gf, x, coeff)) for x in xxx[:m] ]
    combined = combine(gf, shares)
    if combined == secret:
        print "OK"
    else:
        print "Oops!"
        print "- secret", secret
        print "- coeffcients:"
        for i in range(len(coeff)):
            print "  %3d:" % i, list(coeff[i])
        for x, s in shares:
            print "Share %d:" % x, list(s)
        print "- result", combined

def enc_dec_test(gf, count):
    compressed = False
    for i in range(count):
        is_private_key = (i & 3) == 0
        secret = make_secret(CTB_BASE58, is_private_key = is_private_key, compressed = compressed)
        if is_private_key:
            # make sure we do both compressed and uncompressed private keys
            compressed = not compressed
        m = random.randint(1, 16)
        n = random.randint(m, 16)
        make_and_check(gf, CTB_BASE58, m, n, secret,
                random.choice([ random_coeff, sha_coeff ]))


def test():
    gf = GF(0x11d)
    sss_test(gf, 1, 1)
    sss_test(gf, 2, 1)
    sss_test(gf, 1, 2)
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))

    enc_dec_test(gf, 20)

def gen_vectors():
    gf = GF(0x11d)
    make_and_check(gf, CTB_BASE58, 2, 2, make_secret(CTB_BASE58, 0))
    make_and_check(gf, CTB_BASE58, 2, 3, make_secret(CTB_BASE58, data=[42]))
    make_and_check(gf, CTB_BASE58, 1, 1,
            make_secret(CTB_BASE58, data=[1, 2, 3, 4, 5]), set_id="\x12\x34")
    make_and_check(gf, CTB_BASE58, 5, 8,
            make_secret(CTB_BASE58, data=[1, 2, 3, 4, 5]), set_id="XQ")
    make_and_check(gf, CTB_BASE58, 2, 3,
            make_secret(CTB_BASE58, is_private_key = True, compressed = False))
    make_and_check(gf, CTB_BASE58, 4, 4,
            make_secret(CTB_BASE58, is_private_key = True, compressed = True))
    make_and_check(gf, CTB_BASE58, 16, 16,
            make_secret(CTB_BASE58, 16))
    make_and_check(gf, CTB_BASE58, 3, 6,
            make_secret(CTB_BASE58, 32))
    make_and_check(gf, CTB_BASE58, 2, 4,
            make_secret(CTB_BASE58, 64))


#test()
gen_vectors()
