#!/usr/bin/python
#
# Shamir's Secret Sharing proposed BIP.
# Reference implementation.

import hashlib
import binascii
import random           # only when random coefficients are requested

# Galois field GF(2^8)
class GF:
    INFTY = 255         # special case representing log(0)

    def __init__(self, poly):
        # generate exp and log lookup tables
        self.log = [ self.INFTY ] * 256 # allocate log table
        self.exp = [ 0 ] * 256          # allocate exp table
        # compute b = 2**i in GF sequentially for all i from 0 to 254
        b = 1   # 2**0
        for i in range(255):
            self.log[b] = i
            self.exp[i] = b
            # compute next power for the next loop iteration
            b <<= 1
            if b & 0x100:
                b ^= poly

        # check that this polynomial really generates a GF
        assert b == 1
        assert self.log[0] == self.INFTY
        assert self.exp[self.INFTY] == 0

    # arithmetic in the vector space over GF(2^8)
    # where vectors are represented as sequences of GF elements (bytes)

    def vadd(self, u, v):
        assert len(u) == len(v)
        # this is simply bytewise xor, regardless of the poly
        return map(int.__xor__, u, v)

    # multiply vector v by scalar a
    def vmul(self, v, a):
        u = bytearray(len(v))   # allocate the result vector u
        if a == 0:
            return u
        a = self.log[a]
        for i in range(len(v)):
            if v[i] != 0:
                # product's log is the sum of multiplicands' logs, modulo 255
                lp = (self.log[v[i]] + a) % 255
                u[i] = self.exp[lp]
        return u

    # divide scalar a by scalar b
    def div(self, a, b):
        if b == 0:
            raise ZeroDivisionError("division by zero in GF(2^8)")
        if a == 0:
            return 0
        # proper modulus of negative numbers is important!
        lp = (self.log[a] - self.log[b]) % 255
        return self.exp[lp]

# Hash: double SHA-256
def double_sha(seq):
    h = hashlib.sha256(bytearray(seq)).digest()
    h = hashlib.sha256(h).digest()
    return h

base58map = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

# Base-58 encoding of a sequence of bytes
def base58(x):
    # convert sequence to a long number
    n = reduce(lambda a, b: a << 8 | b, x)
    e = ""
    while n:
        e = base58map[n % 58] + e
        n /= 58
    # prepend ones for each zero byte
    for i in x:
        if i:
            break
        e = "1" + e

    return e

def base58check(x):
    x = bytearray(x)
    return base58(x + double_sha(x)[:4])

def unbase58(e):
    n = 0l
    for c in e:
        n = n * 58 + base58map.index(c)
    b = []
    while n:
        b = [int(n & 255)] + b
        n >>= 8
    for c in e:
        if c != '1':
            break
        b = [0] + b

    x = bytearray(b[:-4])
    assert double_sha(x)[:4] == bytearray(b[-4:])

    return x

# Generate coefficients with a deterministic algorithm using SHA-256.
def sha_coeff(secret, m):
    coeff = bytearray(secret)
    res = [coeff]
    for i in range(1, m):
        b = hashlib.sha256(coeff + bytearray([0])).digest()
        while len(b) < len(coeff):
            b += hashlib.sha256(b[-32:]).digest()
        coeff = bytearray(b[:len(coeff)])
        res += [coeff]
    return res

# Generate random coefficients.
def random_coeff(secret, m):
    coeff = bytearray(secret)
    res = [coeff]
    rnd = random.SystemRandom()
    for i in range(1, m):
        coeff = [ int(rnd.getrandbits(8)) for k in range(len(coeff)) ]
        res += [coeff]
    return res

# Compute one share.
# x is between 1 and 255, typically the share's number starting from 1.
# coeff is generated by sha_coeff or random_coeff; len(coeff) == M,
# where M is the number of shares required to reveal the secret.
def make_share(gf, x, coeff):
    s = coeff[0]                # cumulative share (value of the polynomial)
    xpow = 1                    # current power of x, starting from x^0
    for c in coeff[1:]:
        [xpow] = gf.vmul([xpow], x)
        s = gf.vadd(s, gf.vmul(c, xpow))
    return s

# Combine M shares and compute the secret.
# Shares are given as a sequence of pairs (x, share).
def combine(gf, shares):
    m = len(shares)                     # number of shares = M = degree+1
    xxx = [ x for x, s in shares ]      # share indices
    n = [1]                             # preparing Lagrange numerator
    for x in xxx:
        n = gf.vmul(n, x)
    [n] = n
    a = bytearray(len(shares[0][1]))    # cumulative secret: a0
    for x, share in shares:
        lc = gf.div(n, x)               # cumulative Lagrange coefficient
        for xj in xxx:
            if xj != x:
                lc = gf.div(lc, xj ^ x) # lc = lc / (xj - x) in GF
        a = gf.vadd(a, gf.vmul(share, lc))
    return a

# Secret type byte values.
STB_DATA        = 0
STB_PRIVATE_KEY = 1
STB_BIP32_SEED  = 2
STB_BIP32_XPRV  = 3

secret_types = {
        STB_DATA:           "Generic data",
        STB_PRIVATE_KEY:    "Private key",
        STB_BIP32_SEED:     "BIP32 seed",
        STB_BIP32_XPRV:     "BIP32 extended private key",
}

# Encode a share.
# Parameters:
#   secret_type:        one of the values listed above
#   share_set_id:       two bytes identifying this set of shares
def encode(share, secret_type, m, share_set_id):
    x, share = share

    assert x >= 1 and x <= 16
    assert m >= 1 and m <= 16

    return "SSS-" + base58check([secret_type]
                              + list(share_set_id)
                              + [(m-1) << 4 | (x-1)]
                              + list(share))

# Decode a share.
def decode(text):
    assert text[:4] == "SSS-"

    b = unbase58(text[4:])
    secret_type = b[0]
    share_set_id = b[1:3]
    m = (b[3] >> 4) + 1
    x = (b[3] & 0xF) + 1
    share = x, b[4:]

    #print secret_types[secret_type], "ID", binascii.hexlify(share_set_id) + ",",
    #print "M = %d, x = %d" % (m, x)

    return share, m, share_set_id, secret_type

# Make an M-of-N set of shares using hash-based IDs.
def make_set(gf, secret_type, m, n, secret, gen_coeff = sha_coeff):
    assert m >= 1 and m <= 16
    assert n >= 1 and n <= 16

    share_set_id = double_sha(secret)[:2]
    coeff = gen_coeff(secret, m)

    shares = [ (x, bytearray(make_share(gf, x, coeff))) for x in range(1, n+1) ]
    enc = [ encode(share, secret_type, m, share_set_id) for share in shares ]

    print "%d of %d encoding; share set ID %s; share length %d" % (m, n,
            binascii.hexlify(share_set_id), len(enc[0]))

    return shares, enc

def make_and_check(gf, secret_type, m, n, secret, gen_coeff = sha_coeff):
    shares, enc = make_set(gf, secret_type, m, n, secret, gen_coeff)
    set_id = None
    for i, enc_share in enumerate(enc):
        share, dec_m, dec_id, dec_type = decode(enc_share)
        print "  Share %2d: %s" % (share[0], enc_share)
        # check that all IDs in this set are the same
        assert set_id == None or dec_id == set_id
        set_id = dec_id
        # check that everything else is good
        assert dec_m == m and dec_type == secret_type
        assert share == shares[i]
    xxx = range(n)
    random.shuffle(xxx)
    combined = combine(gf, [ shares[i] for i in xxx[:m] ])
    assert combined == secret

def make_secret(secret_type,
                length = None,          # will be random if not given
                data = None,            # will be random if not given
                compressed = True,      # for regular private key
                testnet = False):
    if length == None and data == None:
        length = {
                STB_DATA:        lambda: random.randint(0, 80),
                STB_PRIVATE_KEY: lambda: 32,
                STB_BIP32_SEED:  lambda: random.choice([16, 32, 64]),
                STB_BIP32_XPRV:  "not supported yet",
        }[secret_type]()
    if data == None:
        data = [ int(random.getrandbits(8)) for i in range(length) ]
    if secret_type == STB_PRIVATE_KEY:
        data = [ { False: 0x80, True: 0xef } [testnet] ] + data + \
                { True: [1], False: [] } [compressed]
        text = base58check(data)
    else:
        if data:
            text = binascii.hexlify(bytearray(data))
        else:
            text = "(empty)"
    print
    print secret_types[secret_type] + ": " + text
    return list(data)

def sss_test(gf, q, m):
    secret = [ int(random.getrandbits(8)) for k in range(q) ]
    coeff = random_coeff(secret, m)
    xxx = range(1, 256)
    random.shuffle(xxx)
    print "SSS test: length %d, M = %d:" % (q, m),
    shares = [ (x, make_share(gf, x, coeff)) for x in xxx[:m] ]
    combined = combine(gf, shares)
    if combined == secret:
        print "OK"
    else:
        print "Oops!"
        print "- secret", secret
        print "- coeffcients:"
        for i in range(len(coeff)):
            print "  %3d:" % i, list(coeff[i])
        for x, s in shares:
            print "Share %d:" % x, list(s)
        print "- result", combined

def enc_dec_test(gf, n):
    compressed = False
    for i in range(n):
        secret_type = random.randint(STB_DATA, STB_BIP32_SEED)
        secret = make_secret(secret_type, compressed = compressed)
        if secret_type == STB_PRIVATE_KEY:
            compressed = not compressed
        m = random.randint(1, 16)
        n = random.randint(m, 16)
        make_and_check(gf, secret_type, m, n, secret,
                random.choice([ random_coeff, sha_coeff ]))


def test():
    gf = GF(0x11d)
    sss_test(gf, 1, 1)
    sss_test(gf, 2, 1)
    sss_test(gf, 1, 2)
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))

    enc_dec_test(gf, 20)

def gen_vectors():
    gf = GF(0x11d)
    make_and_check(gf, STB_DATA, 2, 2, make_secret(STB_DATA, 0))
    make_and_check(gf, STB_DATA, 2, 3, make_secret(STB_DATA, data=[42]))
    make_and_check(gf, STB_DATA, 1, 1,
            make_secret(STB_DATA, data=[1, 2, 3, 4, 5]))
    make_and_check(gf, STB_DATA, 5, 8,
            make_secret(STB_DATA, data=[1, 2, 3, 4, 5]))
    make_and_check(gf, STB_PRIVATE_KEY, 2, 3,
            make_secret(STB_PRIVATE_KEY, compressed = False))
    make_and_check(gf, STB_PRIVATE_KEY, 4, 4,
            make_secret(STB_PRIVATE_KEY, compressed = True))
    make_and_check(gf, STB_BIP32_SEED, 16, 16,
            make_secret(STB_BIP32_SEED, 16))
    make_and_check(gf, STB_BIP32_SEED, 3, 6,
            make_secret(STB_BIP32_SEED, 32))
    make_and_check(gf, STB_BIP32_SEED, 2, 4,
            make_secret(STB_BIP32_SEED, 64))


#test()
gen_vectors()
