#!/usr/bin/python
#
# Shamir's Secret Sharing for Bitcoin private keys and BIP32 seeds.
# Reference implementation.

import hashlib
import binascii         # for testing
import random           # only when random coefficients are requested

# Galois field GF(2^8)
class GF:
    INFTY = 255         # special case representing log(0)

    def __init__(self, poly):
        # generate exp and log lookup tables
        self.log = [ self.INFTY ] * 256 # allocate log table
        self.exp = [ 0 ] * 256          # allocate exp table
        # compute b = 2**i in GF sequentially for all i from 0 to 254
        b = 1   # 2**0
        for i in range(255):
            self.log[b] = i
            self.exp[i] = b
            # compute next power for the next loop iteration
            b <<= 1
            if b & 0x100:
                b ^= poly

        # check that this polynomial really generates a GF
        assert b == 1
        assert self.log[0] == self.INFTY
        assert self.exp[self.INFTY] == 0

    # arithmetic on sequences of GF elements (bytes)

    def add(self, a, b):
        assert len(a) == len(b)
        # this is simply bytewise xor, regardless of the poly
        return map(int.__xor__, a, b)

    sub = add

    def mul(self, a, b):
        assert len(a) == len(b)
        c = [0] * len(a)        # allocate sequence c to store the result
        for i in range(len(a)):
            if a[i] == 0 or b[i] == 0:
                c[i] = 0
            else:
                # product's log is the sum of multiplicands' logs, modulo 255
                lp = (self.log[a[i]] + self.log[b[i]]) % 255
                c[i] = self.exp[lp]
        return c

    def div(self, a, b):
        assert len(a) == len(b)
        c = [0] * len(a)        # allocate sequence c to store the result
        for i in range(len(a)):
            if b[i] == 0:
                raise ZeroDivisionError("division by zero in GF(2^8)")
            if a[i] == 0:
                c[i] = 0
            else:
                # proper modulus of negative numbers is important!
                lp = (self.log[a[i]] - self.log[b[i]]) % 255
                c[i] = self.exp[lp]
        return c

base58map = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

# Base-58 encoding of a sequence of bytes
def base58(x):
    # convert sequence to a long number
    n = reduce(lambda a, b: a << 8 | b, x)
    e = ""
    while n:
        e = base58map[n % 58] + e
        n /= 58
    # prepend ones for each zero byte
    for i in x:
        if i:
            break
        e = "1" + e

    return e

def base58check(x):
    x = bytearray(x)
    check = hashlib.sha256(x).digest()
    check = hashlib.sha256(check).digest()
    return base58(x + check[:4])

def unbase58(e):
    n = 0l
    for c in e:
        n = n * 58 + base58map.index(c)
    b = []
    while n:
        b = [int(n & 255)] + b
        n >>= 8
    for c in e:
        if c != '1':
            break
        b = [0] + b

    x = bytearray(b[:-4])
    check = hashlib.sha256(x).digest()
    check = hashlib.sha256(check).digest()
    assert check[:4] == bytearray(b[-4:])

    return x

# Generate coefficients with a deterministic algorithm using SHA-256.
def sha_coeff(secret, m):
    coeff = bytearray(secret)
    res = [coeff]
    for i in range(1, m):
        ci = ""
        for k in range(0, len(coeff), 32):
            ci += hashlib.sha256(coeff[k : k+32]).digest()
        coeff = bytearray(ci[:len(coeff)])
        res += [coeff]
    return res

# Generate random coefficients.
def random_coeff(secret, m):
    coeff = bytearray(secret)
    res = [coeff]
    rnd = random.SystemRandom()
    for i in range(1, m):
        coeff = [ int(rnd.getrandbits(8)) for k in range(len(coeff)) ]
        res += [coeff]
    return res

# Compute one share.
# x is between 1 and 255, typically the share's number starting from 1.
# coeff is generated by sha_coeff or random_coeff; len(coeff) == M,
# where M is the number of shares required to reveal the secret.
def make_share(gf, x, coeff):
    q = len(coeff[0])           # number of bytes
    s = coeff[0]                # cumulative share (value of the polynom)
    xpow = [1]                  # current power of x
    for c in coeff[1:]:
        xpow = gf.mul(xpow, [x])
        s = gf.add(s, gf.mul(xpow * q, c))
    return s

# Combine M shares and compute the secret.
# Shares are given as a sequence of pairs (x, share).
def combine(gf, shares):
    m = len(shares)                 # number of shares = M = degree+1
    q = len(shares[0][1])           # number of bytes
    xxx = [ x for x, s in shares ]  # share indices
    n = [1]                         # preparing Lagrange numerator
    for x in xxx:
        n = gf.mul(n, [x])
    #print "Pre-numerator =", n
    a = [0] * q                 # cumulative secret
    for x, share in shares:
        lc = gf.div(n, [x])     # cumulative Lagrange coefficient
        #print n, "/", x, "=", lc
        for xj in xxx:
            if xj != x:
                lc = gf.div(lc, gf.sub([xj], [x]))
        a = gf.add(a, gf.mul(share, lc * q))
        #print "cumulative a0:", a
    return a

# Encode a share.
# Parameters:
#   network:    "main" or "test"
#   kind:       "cpk" (compressed private key), "upk" (uncompressed) or "seed"
#   compact:    whether to use nibbles for M and X instead of whole bytes
def encode(share, m = None, keyid = None, network = "main", kind = "seed", compact = True):
    long_form = keyid != None and m != None and not compact
    x, share = share

    assert not (compact and m == None)
    assert not (compact and (m > 15 or x > 15))
    assert kind == "seed" or len(share) == 32

    avb, main_prefix, test_prefix = {
        (16, True):  (0x0e, 0x53, 0x55),
        (16, False): (0x15, 0x3c, 0x40),
        (32, True):  (0x1a, 0x46, 0x4c),
        (32, False): (0x26, 0xf4, 0xfc),
        (64, True):  (0x58, 0x72, 0x8a),
        (64, False): (0x83, 0x30, 0x48),
    } [len(share), long_form]

    prefix = { "main": main_prefix, "test": test_prefix } [network]

    if kind != "seed":
        # replace SS/ST -> SK/SL by changing prefix 4.. to 2.. and F.. to C..
        prefix = (prefix - 0x20) & 0xef
        if kind == "cpk":
            prefix += 1

    if compact:
        if len(share) == 16:
            # special case
            prefix -= 1
        else:
            prefix += 2

    payload = [avb, prefix]
    if long_form:
        payload += list(keyid)
        payload += [m]
    if compact:
        payload += [m << 4 | x]
    else:
        payload += [x]
    payload += list(share)

    return base58check(payload)

# Decode a share.
def decode(text):
    payload = unbase58(text)
    avb = payload[0]
    prefix = payload[1]

    q, opt_bytes, validator = {
        0x0e: (16, 3, lambda p: p == 0x53 or p == 0x55),
        0x15: (16, 0, lambda p: p in (0x3b, 0x3c, 0x3f, 0x40)),
        0x1a: (32, 3, lambda p: (p & ~1) in (0x26, 0x2c) or p == 0x46 or p == 0x4c),
        0x26: (32, 0, lambda p: (p & ~0xb) == 0xc4 or (p & ~0xa) == 0xf4),
        0x58: (64, 3, lambda p: p == 0x72 or p == 0x8a),
        0x83: (64, 0, lambda p: (p & ~2) in (0x30, 0x48)),
    } [avb]

    assert validator(prefix)
    assert len(payload) == 3 + opt_bytes + q

    # Determine if we are on the testnet, with special cases for 128-bit seeds.
    if avb == 0x0e:
        testnet = prefix == 0x55
    elif avb == 0x15:
        testnet = prefix > 0x3e
    else:
        testnet = (prefix & 8) != 0

    # If long form, extract M and key hash.
    m = None
    keyid = None
    x = payload[2+opt_bytes]
    if opt_bytes:
        keyid = payload[2:4]
        m = payload[4]
    elif prefix & 2:    # compact form
        m = x >> 4
        x &= 0xf

    share = (x, payload[3+opt_bytes:])

    # Find out if it's a key or a seed.
    kind = "%d-bit seed" % (q * 8)
    if avb == 0x1a and prefix < 0x40 or avb == 0x26 and prefix < 0xf0:
        kind = ("Unc", "C")[prefix & 1] + "ompressed private key"

    print kind + ",",
    if m == None:
        print "M not specified,",
    else:
        print "M = %d," % m,

    if opt_bytes:
        print "long form, key hash", binascii.hexlify(keyid) + ":"
    elif prefix & 2:
        print "compact form:"
    else:
        print "short form:"

    print "- Share %d:" % x, binascii.hexlify(share[1])

def sss_test(gf, q, m):
    secret = [ int(random.getrandbits(8)) for k in range(q) ]
    coeff = random_coeff(secret, m)
    xxx = range(1, 256)
    random.shuffle(xxx)
    print "SSS test: length %d, M = %d:" % (q, m),
    shares = [ (x, make_share(gf, x, coeff)) for x in xxx[:m] ]
    combined = combine(gf, shares)
    if combined == secret:
        print "OK"
    else:
        print "Oops!"
        print "- secret", secret
        print "- coeffcients:"
        for i in range(len(coeff)):
            print "  %3d:" % i, list(coeff[i])
        for x, s in shares:
            print "Share %d:" % x, list(s)
        print "- result", combined

def sss_gen_test_vector(gf, q, m, n, kind = "cpk", form = "long", network = "main"):
    what = {
        "upk":  "Uncompressed private key",
        "cpk":  "Compressed private key",
        "seed": "%d-bit seed" % (q * 8),
    } [kind]
    print
    print "%s, %snet, M = %d, %s form (first %d shares):" % (what, network, m, form, n)
    secret = [ int(random.getrandbits(8)) for k in range(q) ]
    coeff = sha_coeff(secret, m)
    shares = [ (x, make_share(gf, x, coeff)) for x in range(1, n + 1) ]

    print "Secret:", binascii.hexlify(bytearray(secret))

    if kind != "seed":
        key = [ { "main": 0x80, "test": 0xef } [network] ] + secret
        if kind == "cpk":
            key += [1]
        print "Private key:", base58check(key)

    if form == "long":
        keyid = hashlib.sha256(bytearray(secret)).digest()
        keyid = hashlib.sha256(keyid).digest()[:2]
        print "Hash:", binascii.hexlify(keyid)
    else:
        keyid = None

    for share in shares:
        print "Share %d:" % share[0],
        encoded = encode(share, m = m, keyid = keyid, network = network,
                         kind = kind, compact = (form == "compact"))
        print encoded, "(%d chars)" % len(encoded)


def test():
    gf = GF(0x11d)
    sss_test(gf, 1, 1)
    sss_test(gf, 2, 1)
    sss_test(gf, 1, 2)
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))
    sss_test(gf, random.randint(1, 64), random.randint(1, 255))

    sss_gen_test_vector(gf, 32, 1, 2, "upk", "compact", "main")
    sss_gen_test_vector(gf, 32, 2, 3, "upk", "compact", "main")
    sss_gen_test_vector(gf, 32, 2, 3, "upk", "compact", "test")
    sss_gen_test_vector(gf, 32, 2, 3, "cpk", "compact", "main")
    sss_gen_test_vector(gf, 32, 2, 3, "cpk", "compact", "test")
    sss_gen_test_vector(gf, 32, 4, 4, "upk", "compact", "main")
    sss_gen_test_vector(gf, 32, 2, 2, "upk", "long", "main")
    sss_gen_test_vector(gf, 32, 2, 2, "upk", "short", "main")
    sss_gen_test_vector(gf, 16, 2, 3, "seed", "compact", "main")
    sss_gen_test_vector(gf, 16, 2, 3, "seed", "compact", "test")
    sss_gen_test_vector(gf, 32, 2, 3, "seed", "compact", "main")
    sss_gen_test_vector(gf, 32, 2, 3, "seed", "compact", "test")
    sss_gen_test_vector(gf, 64, 2, 3, "seed", "compact", "main")
    sss_gen_test_vector(gf, 64, 2, 3, "seed", "compact", "test")


test()
