<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>
          Nikita Schmidt
          Jan Møller
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing a secret (which may be a Bitcoin private key, a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed or extended private key, or anything else) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that individually the shares do not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme, or M of N secret sharing.
Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of bytes.
* Define ''L'' as the length of the secret, in bytes. For an ordinary Bitcoin private key in SIPA format, ''L'' = 33 or 34.
* Define 1 ≤ ''N'' ≤ 16 as the total number of shares requested.
* Define 1 ≤ ''M'' ≤ N as the number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is an sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K''. <br /><!--
  --> Implementations may use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 0 to ''M''-2:
## split ''a''<sub>''i''</sub> into chunks of 32 bytes (the last chunk can be shorter);
## apply Hash<sub>''w''</sub> to each chunk, where ''w'' is the size of the chunk in bytes;
## let ''a''<sub>''i''+1</sub> be the concatenation of the results of the previous step.
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', 1 ≤ ''x'' ≤ 16.
# The shares are the ordered pairs (''x'', ''y''(''x'')).
Note that although mathematically ''x'' can be any non-zero element of '''GF''', i.e. between 1 and 255, our chosen encoding limits it to the maximum of 16.

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

# Let ''ID'' be a unique identifier for this set of shares; either
#* two random bytes, or
#* Hash<sub>2</sub>(''K''),<br/>at the implementation's discretion.  Its purpose is to help identify which shares belong together.
# For each share (''x'', ''y''(''x'')), construct a payload as follows:
#* Byte 0 is the ''secret type byte'', as enumerated in the table below.
#* Bytes 1 and 2 contain ''ID''.
#* Byte 3 has the value (''M''-1)·16 + (''x''-1).
#* The remaining bytes in the payload are the ''L'' bytes of ''y''(''x'').
# Encode the payload using Base58Check with no application/version byte.

Values of the ''secret type byte'' are allocated as follows.
{|
!Value
!Type of secret
|-
|align="center"|0
|Generic data with application-specific interpretation
|-
|align="center"|1
|Bitcoin private key in SIPA format
|-
|align="center"|2
|BIP32 seed as a sequence of 16, 32 or 64 bytes
|-
|align="center"|3
|BIP32 extended private key
|}

For regular and BIP32-extended private keys, their encoded form before Base58Check is taken as the secret ''K'', including the application/version byte but excluding the checksum.  Consider for example a private key corresponding to a compressed public key:
<div align="center"><code>0x80</code> &lt;private key bytes in big endian order&gt; <code>0x01</code>.</div>

== Motivation ==

A common technique for protecting Bitcoin private keys is to encrypt the private key with a password, such as using [https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki BIP38]. While this protects the key from anyone who cannot determine the password, it also has some significant drawbacks:

# The encryption is only as strong as the password chosen by the user. Human beings are notoriously bad at choosing strong random passwords, and even worse at remembering them.
# Once the key has been encrypted with a password the user is left with two things that he has to keep safe. If one of them is lost the key is lost.

Shamir's Secret Sharing scheme allows you to split any secret into N shares, and set a threshold of M (1 ≤ M ≤ N)  shares that allow you to recombine the secret. A classic example is to configure M=2 and N=3, meaning that you split a secret into 3 shares, and any 2 shares can recombine the secret. When compared to the aforementioned private key encrypted by a password, it fixes both drawbacks:

# There is no potentially weak human generated password.  
# If you lose any one of the three shares due to theft, flood, or fire, you can still recreate the secret by combining the remaining two shares. If an adversary obtains one of two required shares, then the adversary has no better alternative than to brute force the secret.

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== This is not Multi-Sig ===

Bitcoin supports two multi-signature schemes ([https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP11], [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16]), in which redeeming transaction outputs requires signatures by multiple private keys.

This specification is not a replacement for multi-sig transactions. Rather it provides a secure mechanism for storing and protecting private keys and [https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki BIP38] master seeds, which in turn can be used for multi-signature or classic transactions.

== Rationale ==

It is anticipated that 16 shares will be enough for most applications of Shamir's Secret Sharing Scheme. Thus, ''M'' and ''x'' are allocated 4 bits each, and GF(2<sup>8</sup>) is chosen as the underlying field to minimize code complexity.

The ''ID'' and ''M'' fields are located at the beginning of the payload so that all shares for a given secret will share a common prefix and thus can be visually associated.  It can be argued that their inclusion can assist an attacker.  However, this information is essential for secret recovery: the user must know which shares to combine and in what quantity.  If this is not contained in the shares, the user will need to find alternative means of recording this information out-of-band, for example, by writing it down next to each share or memorizing it.  This is inconvenient and/or risky for the user and/or helpful for the attacker in a similar way PINs and passwords are.  The point of Shamir's secret sharing, on the opposite, is to provide a safe, secure and convenient way to keep a secret without passwords.

A common practice is to use the application/version byte (AVB) to both identify the type of payload and force the initial character/s in the Base58Check encoding to a specific prefix, aiding visual recognition of different types of encoded data.  However, the latter is only possible with fixed length payloads.  To preserve both functions of the AVB, this specification proposes to effectively move it outside of the binary payload by attaching the 'SSS-' prefix to the Base58Check encoded string.

== Reference Implementation ==

[https://github.com/cetuscetus/btctool/blob/bip/bip-sss.py bip-sss.py]

This reference implementation is written with the aim of illustrating the algorithm and encoding scheme.  It is not optimized for any specific purpose nor does it follow any specific software development paradigm.

=== Test Vectors ===

A copy is in [https://github.com/cetuscetus/btctool/blob/bip/bip-test.txt bip-test.txt].

<pre>
Generic data: (empty)
2 of 2 encoding; share set ID 5df6; share length 15
  Share  1: SSS-14ZXDtxoVRt
  Share  2: SSS-14ZXE1iukb1

Generic data: 2a
2 of 3 encoding; share set ID ff12; share length 16
  Share  1: SSS-1jfWEJAWq3tp
  Share  2: SSS-1jfWF9jSFTiG
  Share  3: SSS-1jfWFSt3GfJD

Generic data: 0102030405
1 of 1 encoding; share set ID a26b; share length 22
  Share  1: SSS-144mYqGo6HNUVyHcPU

Generic data: 0102030405
5 of 8 encoding; share set ID a26b; share length 22
  Share  1: SSS-144mcTjU44mUVH9QUz
  Share  2: SSS-144mcX3EqoDNfzatiX
  Share  3: SSS-144mcaLzdimJWRtasc
  Share  4: SSS-144mcbvf2srnUWzJSZ
  Share  5: SSS-144mchJmEvCTNY4XRs
  Share  6: SSS-144mcjVAGGCvvQHY3f
  Share  7: SSS-144mcmpREcKJr3dRzH
  Share  8: SSS-144mcqsryAQTMR3BVh

Private key: 5KHCfJ1coRz4wb3K8yQ2oE8zDj5UXPyGhhjd8i9rMcCdDiZT2nu
2 of 3 encoding; share set ID f6dc; share length 59
  Share  1: SSS-RzBL5R47XrKMB4xiqcDsMdEETTqq1TtVFYv23bUx7V26wmEvb5QAErW
  Share  2: SSS-RzBLEPKyLqrL39sAabaY7WWzg3PbKaFvbPcryu6zADjZGT5ACTjkExj
  Share  3: SSS-RzBLNqQnKZpZ12Gu5CVQSCtuc8yMH3sgaeedCxs4h7uEz35FxRWSqDh

Private key: L3dPtsJ2boms2CycFEwCi84t5Z6NieAbRECHcpUTDU97PsTj9y8c
4 of 4 encoding; share set ID 9e73; share length 61
  Share  1: SSS-2ZtoVyQRi8V1ajng5eQBewJqvDxSj4p9XfrPryvZEk6XvSMySgFoSvbKv
  Share  2: SSS-2ZtoWcgHLJc7QdC7rwKojGBMjqrZYiCJWuzyXZ2Yrh5QcWfU97jTZFyry
  Share  3: SSS-2ZtoWutspFJ9DNohXxSrQgqXWj1QsiEBCbBvSMGVNB6kk1BFFHhqr3AoJ
  Share  4: SSS-2ZtoXjPFT6kTt9eDfE42it3sWAF4goCheBsbFDZ64wR5cXYx3Y86iNzns

BIP32 seed: 04648efeca86da6163dd47602682c281
16 of 16 encoding; share set ID 5b40; share length 36
  Share  1: SSS-DTfoPLLyv4PQ3BQh9uFwmxkuLmRXTebe
  Share  2: SSS-DTfoUMW5hP54mP1trNQJ4Ypi7fWcrbxL
  Share  3: SSS-DTfoXr4DvKU5b7Ysax14sbgfte5JW1Jp
  Share  4: SSS-DTfoaCUnUZ9SyErUdkp9wWibNWdyA1Ey
  Share  5: SSS-DTfodK2Lrxz8j6CaF7JfZSEvRWb7eigy
  Share  6: SSS-DTfohBBbpzckZp3NKcmPgJZUjJ19WnWT
  Share  7: SSS-DTfomDJFc58PwMxKFdJGUogQWcwfeyAp
  Share  8: SSS-DTfoqthbDkmqRaU8XwhT8bTAqps312dN
  Share  9: SSS-DTfotLKKDTHKnxe7B63HRUqscrLGDhDS
  Share 10: SSS-DTfoxvLrxXykcpaKP1VzWDf6u8NDyRrx
  Share 11: SSS-DTfp1GH8D1hyFiCabLAoo2boUEuwnwzq
  Share 12: SSS-DTfp65MkFTZCNkEQsM7eT19L1CENTTyH
  Share 13: SSS-DTfp8b8RpavAFdBmRgMcgHbmLFNu73nN
  Share 14: SSS-DTfpD5jDU9TgdT6aYPowU4YxfrPnGwZy
  Share 15: SSS-DTfpFyT27F4tfxXFQV5x9RzJ3Q5zgcZ5
  Share 16: SSS-DTfpKSYF6qa32UqW8KLhtaUFT1npHhbB

BIP32 seed: 6126f07ba60866b740012cf1b88c569e705b42694b70299a4b89c036b36bc6d2
3 of 6 encoding; share set ID 870a; share length 58
  Share  1: SSS-8HU9SVBNGpTaDRyrH9FyuQp16koqa1kY2QDHDQsAR3B3n9NRuUpero
  Share  2: SSS-8HU9VinANWTfHqMS1i5zXFZvraNU8M2p6f8e4WsB5XqpXhLUdayD52
  Share  3: SSS-8HU9XmFcUZcfioeCaSChzCbfue1n2ncytPHLaqRBYz9ftFt84dzWZD
  Share  4: SSS-8HU9YLWUDFj7kn5DUdhe13c46856pkVJF6GKYF8YDgGHDZJ12jp849
  Share  5: SSS-8HU9asAUdUcq5vwFL5SZ3LRX9kfJLVezSFsc6833WeNeEMbKBbu44P
  Share  6: SSS-8HU9dap8xQmWiZAF6BDEX5jgBAowu87SsD8MgUZvtumjx9DJW288XA

BIP32 seed: edb5134d71a12238473dcf9483e6db8e5b741e9c46dc2eaf4cf7486b421c561e1e92e7c5c89512e54ad8eb7befc2019125a48292879208611259862b86be36a8
2 of 4 encoding; share set ID 8d7a; share length 102
  Share  1: SSS-3BkNYaWKZR2Sxnk17J2owupDEizvKaknymiXtfmgHEyboP4Fjf7fu6wV5KnXNJGPD5fPYCrejVEYxhu2rUr4C8cqRNSeTM8RZd
  Share  2: SSS-3BkNYqD8LDcsoCSASeAdczxDkZGsX17VJdJUvLFHGsJTFTWpNrN81izoPknDdjQPiqRZx4NmYbKaHFRbLvtxtEjGTfj7ioc9b3
  Share  3: SSS-3BkNZfJDjrwPAZUXWa9dN85czqxCGUhNRGt3NDZbxNjEkjzeGTgDAcHK2NYcydQyLWuvSaSj4qQPkRtxg8cWbcFHaUWF6ASbr1
  Share  4: SSS-3BkNa4otYod7HZT78YBqUsCVVFRbwk1Lf3TpFaSAffEVvajSfetDvmtJ1c8R5eT9WzDB91wxySxSef3Fgqhktpy7VxPp5ot7tM
</pre>
