<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing a secret (which may be a Bitcoin private key or a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that individually the shares do not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme. Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of 16, 32 or 64 bytes.
* Define ''L'' as the length of the secret, in bytes. For an ordinary Bitcoin private key, ''L'' = 32.
* Define ''M'' ≥ 1 as the minimum number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is an sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K''. <br /><!--
  --> Implementations may use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 0 to ''M''-2:
## split ''a''<sub>''i''</sub> into chunks of 32 bytes (the last chunk can be shorter);
## apply Hash<sub>''w''</sub> to each chunk, where ''w'' is the size of the chunk in bytes;
## let ''a''<sub>''i''+1</sub> be the concatenation of the results of the previous step.
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', x ≠ 0 (i.e. 1 ≤ ''x'' ≤ 255).
# The shares are the ordered pairs (''x'', ''y''(''x'')).

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

Three forms of encoding are specified: long, short and compact.

# Construct a payload as follows:
#* Byte 0 is the ''prefix byte'', as enumerated in the table below.
#* Bytes 1 and 2 contain Hash<sub>2</sub>(''K'') (long form only).
#* Byte 3 has the value ''M'' (long form only).
#* Byte 4 is either:
#** ''x'' for 1 ≤ ''x'' ≤ 255 (long or short form); or
#** ''M''·16 + ''x'' for 1 ≤ ''M'',''x'' ≤ 15 (compact form).
#* The remaining bytes in the payload are the ''L'' bytes of ''y''(''x'').
# If the user chooses short or compact form, bytes 1 through 3 are not included, thereby reducing the length of the payload by 3 bytes. These bytes enable the detection of errors during secret recovery at the cost of disclosing information that could potentially assist an adversary.  The compact form has the same length as the short form, but includes the value of ''M'' and can be used when the total number of shares does not exceed 15.
# Encode the payload using Base58Check with an application/version byte as indicated in the table below.

{|
!rowspan="2"|Secret Size
!rowspan="2"|Form
!rowspan="2"|Application/<br/>Version Byte
!rowspan="2"|Secret Type
!colspan="2"|Prefix Byte
|-
!Mainnet
!Testnet
|-
|rowspan="3"|128 bits
|align="center"|long
|align="center"|<code>0x0E</code>
|rowspan="3" align="center"|seed
|align="center"|<code>0x53</code>
|align="center"|<code>0x55</code>
|-
|align="center"|short
|rowspan="2" align="center"|<code>0x15</code>
|align="center"|<code>0x3C</code>
|align="center"|<code>0x40</code>
|-
|align="center"|compact
|align="center"|<code>0x3B</code>
|align="center"|<code>0x3F</code>
|-
|rowspan="9"|256 bits
|align="center" rowspan="3"|long
|align="center" rowspan="3"|<code>0x1A</code>
|align="center"|uncompressed private key
|align="center"|<code>0x26</code>
|align="center"|<code>0x2C</code>
|-
|align="center"|compressed private key
|align="center"|<code>0x27</code>
|align="center"|<code>0x2D</code>
|-
|align="center"|seed
|align="center"|<code>0x46</code>
|align="center"|<code>0x4C</code>
|-
|align="center" rowspan="3"|short
|rowspan="6" align="center"|<code>0x26</code>
|align="center"|uncompressed private key
|align="center"|<code>0xC4</code>
|align="center"|<code>0xCC</code>
|-
|align="center"|compressed private key
|align="center"|<code>0xC5</code>
|align="center"|<code>0xCD</code>
|-
|align="center"|seed
|align="center"|<code>0xF4</code>
|align="center"|<code>0xFC</code>
|-
|align="center" rowspan="3"|compact
|align="center"|uncompressed private key
|align="center"|<code>0xC6</code>
|align="center"|<code>0xCE</code>
|-
|align="center"|compressed private key
|align="center"|<code>0xC7</code>
|align="center"|<code>0xCF</code>
|-
|align="center"|seed
|align="center"|<code>0xF6</code>
|align="center"|<code>0xFE</code>
|-
|rowspan="3"|512 bits
|align="center"|long
|align="center"|<code>0x58</code>
|rowspan="3" align="center"|seed
|align="center"|<code>0x72</code>
|align="center"|<code>0x8A</code>
|-
|align="center"|short
|rowspan="2" align="center"|<code>0x83</code>
|align="center"|<code>0x30</code>
|align="center"|<code>0x48</code>
|-
|align="center"|compact
|align="center"|<code>0x32</code>
|align="center"|<code>0x4A</code>
|}

Bit 1 (mask 0x02) of the prefix byte differentiates between short and compact forms:
* when not set, byte 4 of the payload is ''x'';
* when set (and the A/V byte indicates it's not a long form), byte 4 of the payload contains M in the higher nibble and x in the lower one.

Bit 0 (mask 0x01) of the prefix byte indicates, when the secret is a private key, that this key should be used with a compressed public key.

Bit 3 (mask 0x08) of the prefix byte is a testnet indicator except for the special case of the 128-bit BIP32 seed.

== Motivation ==

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== Comparison with Alternatives ===

Bitcoin supports [https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki a multi-signature scheme], in which redeeming transaction outputs requires signatures by multiple private keys. In theory this achieves the same objective as the application of Shamir's Secret Sharing Scheme to a single private key: namely, multiple pieces of information are required in order to spend the funds at an address, and any sufficiently large subset of the corpus of all such pieces of information suffices. Further, the multi-signature scheme has the advantage that the signatures can be computed independently at separate times and places. However, one critical disadvantage of the multi-signature scheme is the space it consumes in the block chain: all public keys in the corpus must be embedded in the scriptSig of every input that claims a multi-signature output. For this reason, "standard" multi-signature scriptSigs are presently limited to containing no more than three public keys. Even if this limitation were to be lifted, the multi-signature scheme would still yield rather large (and thus costly) scriptSigs. Another, lesser disadvantage of the multi-signature scheme is that it is more cumbersome for users to manage, as not only must users store the private keys, but they must also store a "redeem script."

In comparison to the multi-signature scheme, Shamir's Secret Sharing Scheme has the disadvantage that a sufficient number of shares must be brought together in one place at one time in order to recover the private key that is needed for signing a transaction. However, it has several advantages:
* No new address format is used, so all first-generation Bitcoin infrastructure already supports it implicitly.
* Any number of shares can be generated and distributed without increasing the size of the scriptSig.
* Any subset size can be required for successful key recovery without increasing the size of the scriptSig and without increasing the number of signature verification operations necessary to validate the transaction.
* It can be extended to other secrets besides private keys, such as [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds.

=== Use with Multi-signature ===

Shamir's Secret Sharing Scheme can be used in conjunction with the multi-signature scheme mentioned above. As an example, consider a hypothetical organization that stores its operating funds at a 3-of-3 multi-signature address. Spending funds from this address requires signatures from the president, the chief financial officer, and the board of directors. Ideally, getting a signature from the board of directors should require the consent of a majority of the board, but if any single director has possession of the board's private key, then this "majority required" policy cannot be enforced cryptographically. However, if a distinct Shamir share, derived from the board's private key, is distributed to each director, then only a sufficiently large subset of the directors, working together, can recover the board's private key and sign the transaction.

== Rationale ==

It is anticipated that 255 shares will be more than enough for most applications of Shamir's Secret Sharing Scheme to Bitcoin private keys and BIP32 master seeds. Thus, to minimise code complexity, GF(2<sup>8</sup>) is chosen as the underlying field.

The application/version bytes and prefix bytes were chosen to force the initial characters in the Base58Check encoding for mainnet keys to "SK" and seeds to "SS", which can be taken as standing for "Shamir share of a Key or Seed." Testnet keys/seeds have prefixes of "SL" and "ST" respectively.

The Hash<sub>2</sub>(''K'') and ''M'' fields are located at the beginning of the payload so that all shares for a given secret will share a common prefix and thus can be visually associated.

== Reference Implementation ==

[bip-sss.py]

=== Test Vectors ===

A set of test vectors is in [bip-test.txt].  More can be generated with [bip-sss.py].  Below are a few examples.

* '''Uncompressed private key, mainnet, ''M'' = 2, compact form''' (first 3 shares)
** Secret: <code>ee642633bb066381cc22c289c30190ec11b967445a38110c8491702f34dcaf1b</code>
** Private key: <code>5KdGxvP4QWyAcMBaqaixTrksuLFSBaDCRUCv2sykzNBqzSJQmku</code>
** Share 1: <code>SKMaGkFbPWiyve22b3oBcBZSNbNWu9qzqfKZWuBgn7sCZgFsqizNq</code> (53 chars)
** Share 2: <code>SKMcsd7jgD5MJk2YSzNpyDnugi2hqcLghhPnbhvDbWECzNfkJNc53</code>
** Share 3: <code>SKMfG8ZUkKKT6VJDVDmpUjjNJMqtLE5csjaauxUhb9zo7XdoWDqzP</code>
* '''Compressed private key, testnet, ''M'' = 2, compact form''' (first 3 shares)
** Secret: <code>fa0487b457d96b820ac31d6f8a0e8efad79844219096783e3484cf09b24a516b</code>
** Private key: <code>cVxhkPaB89GWJn65M3RtsFK6wCG7sTcJ5LnW2ZMUcCU2zxr24iQ7</code>
** Share 1: <code>SLgoCtUFveresUizAcLqvhL3bwqQ7hudsSkUY1wG4vn2gfvcPgiXx</code> (53 chars)
** Share 2: <code>SLgqcW4h8bEeFgLRH2CQrWSc5KR5SbLX5nR8Q2VyDgjtrKNMpjc7m</code>
** Share 3: <code>SLgrwc4QY3P6qSPcrfzXEzq4kvekYMQhZLyk1Bcw73SfSG5hpnVf5</code>
* '''Uncompressed private key, mainnet, ''M'' = 2, long form''' (first 2 shares)
** Secret: <code>9074db560ac377aa7a9efa6c2ab8c32ac90ffeff251e28edcdf5b89a12ed235a</code>
** Private key: <code>5JuuXb7tQNk1Nmme7Nqs3Pe3o7iSECzdRDmEb5U8ekHazrTnB3u</code>
** Hash: <code>dcd3</code>
** Share 1: <code>SKFd7FtmvyZLH3VRLMUjdkpQRi5DBpYiEDWaGt2tigybUusNANSBpT76o</code> (57 chars)
** Share 2: <code>SKFd7Ftq4EgoevCaicMcCRrhgBP2wiqUE6hresfHN5gZqBAeqSVxUqjHE</code>
* '''128-bit seed, mainnet, ''M'' = 2, compact form''' (first 3 shares)
** Secret: <code>bd6b8f33bad1d3314f040a49aea3613e</code>
** Share 1: <code>SS9yu27afjaGGfCtGYrvojo8HmxhWHW</code> (31 chars)
** Share 2: <code>SS9zmdhsMcSm7YFzGnMxykYLnCc5hce</code>
** Share 3: <code>SSA5AKrXof6F6u1Ytv5rRWhiXaCZkBs</code>
