<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>,
          Nikita Schmidt,
          Jan Møller,
	  Jérôme Rousselot
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing an arbitrary secret (for example, a Bitcoin private key, a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] extended private key, or anything else) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that any smaller subset does not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme, or M of N secret sharing.
Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of bytes.
* Define ''L'' as the length of the secret, in bytes.
* Define 1 ≤ ''N'' ≤ 16 as the total number of shares requested.
* Define 1 ≤ ''M'' ≤ N as the number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is a sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K'', but knows Hash<sub>2</sub>(''K'') and some parts of ''a''. <br /><!--
  --> Implementations may use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 1 to ''M''-1:
## for each ''j'' from 0 to (''L''-1) / 32:
##* let ''b''<sub>''i'',''j''</sub> := SHA-256(''K'' || ''i'' || ''j''),<!--
  --> <br/>where || denotes concatenation, and numbers ''i'' and ''j'' are represented as implementation-defined byte sequences for concatenation (e.g. as single bytes with the corresponding values)
## let ''a''<sub>''i''</sub> be the first ''L'' bytes of ''b''<sub>''i'',0</sub> || … || ''b''<sub>''i'',(''L''-1)/32</sub>
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', 1 ≤ ''x'' ≤ 16.
# The shares are the ordered pairs (''x'', ''y''(''x'')).
Note that although mathematically ''x'' can be any non-zero element of '''GF''', i.e. between 1 and 255, our chosen encoding limits it to the maximum of 16.

'''Do not use deterministic coefficients with short secrets.'''  Note that the strength of the deterministic coefficient generation algorithm is the same as the strength of the secret.  When sharing a short secret which is intended as an input to a key extension function of high complexity, such as scrypt, a brute force attack on the coefficients derived from the secret is much faster than an attack on the secret itself, even if the attacker knows only one share.

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

# Let ''ID'' be a unique identifier for this set of shares; either
#* two random bytes, or
#* Hash<sub>2</sub>(''K''),<br/>at the implementation's discretion.  Its purpose is to help identify which shares belong together.
# For each share (''x'', ''y''(''x'')), construct a payload as follows:
#* Byte 0 is the extensible ''content type byte'', 0=Base58 and future BIPs may extend it
#* Bytes 1 and 2 contain ''ID''.
#* Byte 3 has the value (''M''-1)·16 + (''x''-1).
#* The remaining bytes in the payload are the ''L'' bytes of ''y''(''x'').
# Encode the payload using Base58Check and prefix it with "SSS-".

Content type 0 provides for a universal container of any data represented in Base58Check encoding (such as Bitcoin private key in Wallet Import Format).
The secret (''K'') is the binary form of the decoded Base58Check value excluding the checksum.  Consider for example a Bitcoin private key, which is to be used with a
compressed public key:
<div align="center">''K'' = <code>0x80</code> &lt;private key bytes in big endian order&gt; <code>0x01</code>.</div>

In effect a collection of shares is a wrapper around a Base58Check value, without the overhead of encoding Base58Check twice.

== Motivation ==

Secure longterm backup and storage of secrets is of particular importance to Bitcoin users. So far various techniques have been used including storing plain text private and password encrypted private keys on paper.

Storing plaintext private keys has the obvious drawback that anyone who sees it can steal your funds.

Storing password encrypted private keys has another drawback. You turn your private key into two components, where both are needed to reveal the private key. While you prevent someone getting one component from revealing the private key, you make it more likely that you loose control over your private key yourself. If you lose one component due to flood, theft, or fire, you lost control over your private key.

With this BIP we propose to standardize longterm storage of secrets using an M of N secret sharing scheme commonly known as Shamir's Secret Sharing. The secret is split into N shares where any M of those shares reveal the secret. N and M can freely be chosen as long as 1 ≤M ≤ N ≤ 16. A classic example is to configure M=2 and N=3, meaning that the user splits a secret into 3 shares, and any 2 shares can recombine the secret. This means that if any one share is stolen or lost you can reconstruct the secret by the remaining two shares. On the other hand, an adversary with one share can reveal nothing about the secret. If you choose M=2 and N=2 you have a setting comparable with classic password encrypted private keys, with the added benefit that both components are equally strong.

=== This is not Multi-Sig ===

Bitcoin supports two multi-signature schemes ([https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP11], [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16]), in which redeeming transaction outputs requires signatures by multiple private keys.

This specification is not a replacement for multi-sig transactions. Rather it provides a secure mechanism for storing and protecting private keys or potentially master seeds, which in turn can be used for multi-signature or classic transactions.

== Rationale ==

It is anticipated that 16 shares will be enough for most applications of Shamir's Secret Sharing Scheme. Thus, ''M'' and ''x'' are allocated 4 bits each.

Each share encodes the content type, which is extensible in future BIPs. So far the content type is limited to Base58. Applications supporting this BIP can use conventional Base58 prefix detection to determine how to handle the payload). By supporting Base58 content this specification builds on top of several actual and de facto standards with Bitcoin today, including WIF private keys, BIP32 extended private keys, and BIP38 encrypted private keys.

Each share in a set of compatible shares encode the same random identifier ''ID'' which allows software to guide the user when importing shares. This dramatically reduces the probability of user attempting to combine incompatible shares.

Each share encodes the number ''M'' of shares necessary to combine the secret. This allows software to tell the user how many shares he should collect. 

Each share in a set of compatible shares have a unique serial number ''x'' ≤ ''M''. This allows software to guide the user which shares to pick, and prevents that the same share is applied twice, yielding a wrong result.

A common practice is to use the application/version byte (AVB) to both identify the type of payload and force the initial character/s in the Base58Check encoding to a specific prefix, aiding visual recognition of different types of encoded data.  However, the latter is only possible with fixed length payloads.  To preserve both functions of the AVB, this specification proposes to effectively move it outside of the binary payload by attaching the 'SSS-' prefix to the Base58Check encoded string.

An earlier draft of this specification proposed GF(''P'') as the field, where ''P'' was a large prime number close to 2<sup>8''L''</sup>, specified individually for each possible value of ''L''.  In order to support arbitrary length secrets, the field was changed to GF(2<sup>8</sup>).

A timestamp field was discussed, which would be useful to determine the key inception time point to optimize private key import into a wallet.  However, it has no general use in the secret sharing scheme and belongs rather to the payload data.  An encoding that contains inception time, e.g. as [https://bitcointalk.org/index.php?topic=258678.0 proposed by J.-P. Kogelman and W. Yager], canbe used as the content payload.

== Reference Implementation ==

[https://github.com/cetuscetus/btctool/blob/bip/bip-sss.py bip-sss.py]

This reference implementation is written with the aim of illustrating the algorithm and encoding scheme.  It is not optimized for any specific purpose nor does it follow any specific software development paradigm.

=== Test Vectors ===

A copy is in [https://github.com/cetuscetus/btctool/blob/bip/bip-test.txt bip-test.txt].

<pre>
Generic data: (empty)
2 of 2 encoding; share set ID 5df6; share length 14
  Share  1: SSS-EGCEhcC94d
  Share  2: SSS-EGCEpYoMeV

Generic data: 2a
2 of 3 encoding; share set ID ff12; share length 16
  Share  1: SSS-2UV2RrEUJTRk
  Share  2: SSS-2UV2SEgpvuRu
  Share  3: SSS-2UV2SmDVHSAg

Generic data: 0102030405
1 of 1 encoding; share set ID a26b; share length 21
  Share  1: SSS-8txqHtUghKJLrAF13

Generic data: 0102030405
5 of 8 encoding; share set ID a26b; share length 21
  Share  1: SSS-8txttSnh3TAKB7dCV
  Share  2: SSS-8txtzFWa68hUQ8Lky
  Share  3: SSS-8txu2FsNVj5HQR4as
  Share  4: SSS-8txu4kTYmcePqpd9x
  Share  5: SSS-8txuAR421JSp6Lo8g
  Share  6: SSS-8txuDudvrVBCLiSWm
  Share  7: SSS-8txuFu9y4du1vH4jq
  Share  8: SSS-8txuHKfcwJopauEjJ

Private key: 5KX5JknPztEdGp3HuHKWz1zKNtgbi6AYoR1tA4rGnUAwzSxzZyD
2 of 3 encoding; share set ID ba31; share length 59
  Share  1: SSS-bh6pjz49szVLo1WUEYywkaCqK4CGWhoHo2UvngPegtWqSbsRAM6BW5m
  Share  2: SSS-bh6pnrPJfoe8a6DaJAQrgPkYnjYjb9dPAzPpQDKipoTMQWZj6tm19fN
  Share  3: SSS-bh6pz3HGo6UsSNZzobdRUmDsJoazuXFuRnM1bWwVhsaJ2Hk6SsumHYW

Private key: L4FWwzuxPn4gU5z8oVBwErWFJrZGMVdSx6YiYZj3y3G1JBLkF3HT
4 of 4 encoding; share set ID 6ea2; share length 61
  Share  1: SSS-3MYty2enHnEGMW44rWCuoaDU2pDRN6i1yazfyLZ6xWYatH9GpfkHwa1vi
  Share  2: SSS-3MYtyyWR368SGTLVLgnohjnLAtrxjLp3TaTEbs4BiRiCpi84hmg3rBXUk
  Share  3: SSS-3MYtzUeuKS41AHXeVZ6Fj1nAp8bKrjADvgU4PErtzu9zLkkJLABd5RCaY
  Share  4: SSS-3MYu1DyyvF9qMMxKPAULR93XPUU5EkuTAeYwhzwR3MvEnQbd4UUcrxkPj

BIP32 seed: 83b9dae544cd7567c0e99d9e5a27588b
16 of 16 encoding; share set ID 975d; share length 36
  Share  1: SSS-KzMjeSbodoQt3yQskHRskTvgkNaso5BM
  Share  2: SSS-KzMjj8zq9FLGX7wanvBdRTEjdkEtMUq2
  Share  3: SSS-KzMjnFdFwMJmvZiGgYBL9vrMytAnnxUa
  Share  4: SSS-KzMjs6RUEQmsWfSJC56KEeu6aiV5eVGK
  Share  5: SSS-KzMjufcCcnfqffQ5AuLj1nu884qxenDk
  Share  6: SSS-KzMjz4anKdAkNG28D9HAy6hdSGZhZBkc
  Share  7: SSS-KzMk4LZLxzqyNv9WbPCuXXeZ7GP3v7Ju
  Share  8: SSS-KzMk5JeQrNihCtrfCJpdKQyyzNw3stsg
  Share  9: SSS-KzMkBgzUCuBgRrE35SXj937UrL8KqTCp
  Share 10: SSS-KzMkEHYpPjHbdtJuc6pczt11oQS4xYu2
  Share 11: SSS-KzMkG3KfDvdfpdu6d3uDvZBEDbfEr7j5
  Share 12: SSS-KzMkLdN5sdCYhcGMCf1YZ1P26G3dthyG
  Share 13: SSS-KzMkPsbpyAhQh2FxA5WLwiSo7HQcLKyE
  Share 14: SSS-KzMkTfveXG7zXQ8g99cHEAAsv7LUf83q
  Share 15: SSS-KzMkXbMSq5ZWf8v8UQhTYyJJBUhK4Kdr
  Share 16: SSS-KzMkb1hcUjc2ngmp18jXfWe7RhXeL6y9

BIP32 seed: c4011cbcbdd5ae7d866b7baeba6383735c11cb6ea46fad49e990b2a413aee2f0
3 of 6 encoding; share set ID 9f97; share length 58
  Share  1: SSS-BSeVvKiK98fARMnHGPTJP2GXa6DAK3R9wTWr27XFGiZFcQHdsGX9BG
  Share  2: SSS-BSeVxv6xpKssMa4tNtHM4mxJRB1KM4dx1CsWMtscywgsYub8YYbxjY
  Share  3: SSS-BSeVzbzoyLpDy6uifRz66CXMajoPH8siQDqh6bV3uPMRSS5VsdqcS1
  Share  4: SSS-BSeW2hYuTrvXG9krcTUp2cTzgSr5MYCB5uwznzPG18zvhhKsNjKkze
  Share  5: SSS-BSeW4bXZdYaTewS1AypoJNaeBsHTpoJ7MucjEvTCkFkCCK3U6a4tRb
  Share  6: SSS-BSeW7E8x6p3FXYkC56RjRFx1qNtxdi6hf2Lhcig8bxHSMwtvM85FD4

BIP32 seed: 5d1c618e26ccc9ec6f7fc09e36a1dec35a464b17f15bee924d1a17c6b041526a37591ddd320bfe683f5805511a6ce58bbbd9096e6b91fe1591960ed653be5089
2 of 4 encoding; share set ID 4d4b; share length 102
  Share  1: SSS-3pxEciXPAqz7zUxXDKdgP8SJTPbhFSv5STXYKSLQQKqsrqw8DZ3Ag6d9t72z16ang3CQthEpDShktZ8vPY1KkRbMNtqH95JdAN
  Share  2: SSS-3pxEd4t3bGWryP4DTF3hy2Aj2TDT9HshWwtFaFPneWMfaESN8LGhhpmdCJm8zcKFdPSe9sgDLejz2kxtrjZ5JdB8tRdtyb6PeF
  Share  3: SSS-3pxEdi7D4Z8HR3Dc7mBhACcKZq3a59AeTKHHV8pEGyFBBHCw2oJrx56RueSbf5W1JR7144VrNYJ9nfn9UQWWUNpJMDkJ9f5DJh
  Share  4: SSS-3pxEedyJBCh4jghSHCCEjuypXCoQsEKekZAERjmnZRkYKa94SL6yreF96tSfcC8NRgZaCZNyaLvM13azdUDUDHfufyTohLXqjd
</pre>
