<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>,
          Nikita Schmidt,
          Jan Møller,
	  Jérôme Rousselot
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing an arbitrary secret (for example, a Bitcoin private key, a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed or extended private key, or anything else) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that any smaller subset does not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme, or M of N secret sharing.
Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of bytes.
* Define ''L'' as the length of the secret, in bytes. For an ordinary Bitcoin private key in SIPA format, ''L'' = 33 or 34.
* Define 1 ≤ ''N'' ≤ 16 as the total number of shares requested.
* Define 1 ≤ ''M'' ≤ N as the number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is a sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K'' or Hash<sub>2</sub>(''K''). <br /><!--
  --> Implementations may use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 1 to ''M''-1:
## let ''b''<sub>''i'',0</sub> := SHA-256(''a''<sub>''i''-1</sub> || 0),<br/>where || denotes concatenation and 0 is a zero byte
## for each ''j'' from 1 to (''L''-1) / 32: let ''b''<sub>''i'',''j''</sub> := SHA-256(''b''<sub>''i'',''j''-1</sub>)
## let ''a''<sub>''i''</sub> be the first ''L'' bytes of ''b''<sub>''i'',0</sub> || … || ''b''<sub>''i'',(''L''-1)/32</sub>
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', 1 ≤ ''x'' ≤ 16.
# The shares are the ordered pairs (''x'', ''y''(''x'')).
Note that although mathematically ''x'' can be any non-zero element of '''GF''', i.e. between 1 and 255, our chosen encoding limits it to the maximum of 16.

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

# Let ''ID'' be a unique identifier for this set of shares; either
#* two random bytes, or
#* Hash<sub>2</sub>(''K''),<br/>at the implementation's discretion.  Its purpose is to help identify which shares belong together.
# For each share (''x'', ''y''(''x'')), construct a payload as follows:
#* Byte 0 is the ''secret type byte'', as enumerated in the table below.
#* Bytes 1 and 2 contain ''ID''.
#* Byte 3 has the value (''M''-1)·16 + (''x''-1).
#* The remaining bytes in the payload are the ''L'' bytes of ''y''(''x'').
# Encode the payload using Base58Check with no application/version byte.

Values of the ''secret type byte'' are allocated as follows.
{|
!Value
!Type of secret
|-
|align="center"|1
|Octet string with application-specific interpretation
|-
|align="center"|2
|Any type of data for which a unique Base58Check encoding is specified<br/>(such as Bitcoin private key in SIPA format)
|-
|align="center"|3
|BIP32 seed as a sequence of 16, 32 or 64 bytes
|}

Type 2 provides for a universal container for any data (usually Bitcoin-related) that are usually represented in Base58.

When sharing type 2 secrets, their encoded form before Base58Check is taken as the value of ''K'', including the application/version byte but excluding the checksum.  Consider for example a private key corresponding to a compressed public key:
<div align="center">''K'' = <code>0x80</code> &lt;private key bytes in big endian order&gt; <code>0x01</code>.</div>

== Motivation ==

The backup storage of Bitcoin private keys and [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds is of critical importance to users. Indeed, the loss of a bitcoin wallet means losing all bitcoins stored on the addresses managed by that wallet, if no backup was made. However, simply saving the private key on paper (cold storage) is not enough. What happens when this document is lost ? It may be password protected, for instance using [https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki BIP38]. But what if the user selected a weak password, for instance a date of birth, so that he is sure he can remember it ? This is very common, as described in [http://research.microsoft.com/pubs/74164/www2007.pdf large-scale-study-web-passwords]. Therefore, key stretching may not be secure enough against some dictionary attacks. If the backup is lost, then the funds can be lost as well. A backup in another location is the ideal solution to this problem. But trusting a third party with a private key also carries significant risk.

We suggest to use Shamir's Secret Sharing scheme, as it reduces the risks associated with the loss of one of the paper backups, and with entrusting a third party with the paper backup.

Shamir's Secret Sharing scheme allows the user to split any secret into N shares, and set a threshold of M (1 ≤ M ≤ N)  shares that allow the user to recombine the secret. A classic example is to configure M=2 and N=3, meaning that the user split a secret into 3 shares, and any 2 shares can recombine the secret. This secret can be encrypted by a password, although this is not required.

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== This is not Multi-Sig ===

Bitcoin supports two multi-signature schemes ([https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP11], [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16]), in which redeeming transaction outputs requires signatures by multiple private keys.

This specification is not a replacement for multi-sig transactions. Rather it provides a secure mechanism for storing and protecting private keys and [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds, which in turn can be used for multi-signature or classic transactions.

== Rationale ==

It is anticipated that 16 shares will be enough for most applications of Shamir's Secret Sharing Scheme. Thus, ''M'' and ''x'' are allocated 4 bits each.

The ''ID'' and ''M'' fields are located at the beginning of the payload so that all shares for a given secret will share a common prefix and thus can be visually associated.  It can be argued that their inclusion can assist an attacker.  However, this information is essential for secret recovery: the user must know which shares to combine and in what quantity.  If this is not contained in the shares, the user will need to find alternative means of recording this information out-of-band, for example, by writing it down next to each share or memorizing it.  This is inconvenient and/or risky for the user and/or helpful for the attacker in a similar way PINs and passwords are.  The point of Shamir's secret sharing, on the opposite, is to provide a safe, secure and convenient way to keep a secret without passwords.

No provision has been made to make ''ID'' and ''M'' optional.  This is to reduce implementation burden associated with the complex logic required to handle cases when either or both are omitted, particularly in applications with a focus on user interface.

A common practice is to use the application/version byte (AVB) to both identify the type of payload and force the initial character/s in the Base58Check encoding to a specific prefix, aiding visual recognition of different types of encoded data.  However, the latter is only possible with fixed length payloads.  To preserve both functions of the AVB, this specification proposes to effectively move it outside of the binary payload by attaching the 'SSS-' prefix to the Base58Check encoded string.

An earlier draft of this specification proposed GF(''P'') as the field, where ''P'' was a large prime number close to 2<sup>8''L''</sup>, specified individually for each possible value of ''L''.  In order to support arbitrary length secrets, the field was changed to GF(2<sup>8</sup>).

A timestamp field was discussed, which would be useful with BIP32 payloads as the key inception time point to optimize private key import into a wallet.  However, it has no general use in the secret sharing scheme and belongs rather to the shared data.  An encoding that contains inception time, such as [https://bitcointalk.org/index.php?topic=258678.0 this one], can be used as a type 2 secret instead of the plain seed (type 3).

== Reference Implementation: to be updated ==

[https://github.com/cetuscetus/btctool/blob/bip/bip-sss.py bip-sss.py]

This reference implementation is written with the aim of illustrating the algorithm and encoding scheme.  It is not optimized for any specific purpose nor does it follow any specific software development paradigm.

=== Test Vectors (to be updated) ===

A copy is in [https://github.com/cetuscetus/btctool/blob/bip/bip-test.txt bip-test.txt].

<pre>
Generic data: (empty)
2 of 2 encoding; share set ID 5df6; share length 15
  Share  1: SSS-14ZXDtxoVRt
  Share  2: SSS-14ZXE1iukb1

Generic data: 2a
2 of 3 encoding; share set ID ff12; share length 16
  Share  1: SSS-1jfWEHX9ZuJe
  Share  2: SSS-1jfWEg4JWqva
  Share  3: SSS-1jfWFCYeyJ5a

Generic data: 0102030405
1 of 1 encoding; share set ID a26b; share length 22
  Share  1: SSS-144mYqGo6HNUVyHcPU

Generic data: 0102030405
5 of 8 encoding; share set ID a26b; share length 22
  Share  1: SSS-144mcRq76dWLQsLd21
  Share  2: SSS-144mcXdpygBsWrbvwu
  Share  3: SSS-144mcZeBn5nFR3xTPN
  Share  4: SSS-144mcc8mxMfpT3bkJP
  Share  5: SSS-144mchoNRbMcqidZ83
  Share  6: SSS-144mcmHxLSYMGJvaDL
  Share  7: SSS-144mcoHUNeh59BBAwr
  Share  8: SSS-144mcphz2XMyukfHDy

Private key: 5KgkzaRPWJpM9KESerGdw1T9DNxVTATbfEwf3Wn4eaAxHZ8jBgC
2 of 3 encoding; share set ID 3454; share length 59
  Share  1: SSS-GKZgn3rhrMswDVGvcHQbaMxctHuC6MLWgiwgPcsCPKEChuwZBYWohN7
  Share  2: SSS-GKZgqL2uyexsX4qvU3iCQDuXWPk8fLLHCUXJCZHNExSGZ3TeY9T69L1
  Share  3: SSS-GKZgxuYFAsndsz4prs8RsmVjk5i9XnfZq8btfDVs94tJqsUmct9ZZGd

Private key: L1yT2XcuBU2jiww6acKR6M83qHNc9bkxFQJRHbpP78ikU5vVfVNF
4 of 4 encoding; share set ID fce1; share length 61
  Share  1: SSS-2vbwv97BurRW5Xci1tezqpoMYgXFGSoN8pNFhj9p9wv1akLxPQkYZ1Dar
  Share  2: SSS-2vbwvZUvKPrGVe6YPQk3PCSjrfyBKBdvWPkMwLpkcZWCiGeuz9Yfov1bj
  Share  3: SSS-2vbwwnqMLXcrY19TN1jpzCmZGiRfbWeS3kkLTLr9htzvf2qERcM8PkGrX
  Share  4: SSS-2vbwxGGyMZmwVSqhsT7zJN2fC5RZv54Yk4VpKneqjVKmPigx4A4JWADLu

BIP32 seed: a8207b01f76a82cc5cf0ea1ec224370e
16 of 16 encoding; share set ID 27c4; share length 36
  Share  1: SSS-CPzbxpthnNxZQoLeGPXQTidZAkV5hPN2
  Share  2: SSS-CPzc3Kwnx1hZEcvDicxdGthnHzACBYBB
  Share  3: SSS-CPzc59jBF3vZoqNuTYXc9No2G4AnP1XA
  Share  4: SSS-CPzcAYQacv8iTZpjG8yMuKinzQ3ZS2UA
  Share  5: SSS-CPzcBLMLUYxc3KCvTpAmmRhvjGhRHQWS
  Share  6: SSS-CPzcHPyroivuijMEJKYZLvkVUiU2R5JA
  Share  7: SSS-CPzcKypfUqZ8HQsbx5VvmJSdZRLAzovv
  Share  8: SSS-CPzcQZEAFfmzXNQniRLe7Rgb4GgAkcyJ
  Share  9: SSS-CPzcRqxDaKJDKUnJU2LNcMkHvExEAaRr
  Share 10: SSS-CPzcWoyuUpRzqxRTpWanc55FLQZum9yw
  Share 11: SSS-CPzcZmoJSj6384SxKWyEV1aEqBe2rXE7
  Share 12: SSS-CPzcdeAvfRMuFspoA9nXymGNfUV4whtB
  Share 13: SSS-CPzcgKabNT3sXxVAt1v6djkffneWs6zF
  Share 14: SSS-CPzcnXzQXSeDXbbZnQh7qnREaV2REnBM
  Share 15: SSS-CPzcomFbmsNHjM74VZW266kfHB3f56gD
  Share 16: SSS-CPzctt4qww7vwHdc95to8nr46wb7Qqx1

BIP32 seed: b5e6838bca5aec9eb6c6e61fec32b1b56779647852f69578d97471c1936387c8
3 of 6 encoding; share set ID d86e; share length 58
  Share  1: SSS-9CcNxASM5gQ1EjvbxgKVafx8CMzgE8S3VH1cfPRkDEsb5DqDEHeMCb
  Share  2: SSS-9CcNymVSADPUCfrH8FM2D73aqpQcxm9woxDNNtgdBc574x68Gfxmn1
  Share  3: SSS-9CcP25RWAdLutZTdx8LArQoYZMA7D4h2RTcJKbBuNzGbGKS8p1nMYf
  Share  4: SSS-9CcP2YvrxdNhU2TB8xNU8R6L2B1CGRZoLG9nyZsBHhft4gfYtU8fdD
  Share  5: SSS-9CcP56xKM32eHVAcAscZb7MzA2L4odxcT7ngxX4QGQ9NQ9zwGKdrUd
  Share  6: SSS-9CcP6U7bjQ4UCHyUYjrv2Mhxa35XKYpF5uRGXuaGLAgqBNtCDtSJWz

BIP32 seed: e67be8895c6aa05aad38b5b9e1b88f03c018ec0452e424e9d44d5a110053a433e201198500064a64faf7da6d39dd103a1df377bd229112432d89b960827eb039
2 of 4 encoding; share set ID 31ab; share length 102
  Share  1: SSS-2swZQjerTh2ARfxf2bAtZG1qegqbS67gu8tfRLHVDjcPpQki9KhmEqsyFyH7njuHXEvSoBcp1J4zMYc9tZZDrha7MDYjrKT9Tz
  Share  2: SSS-2swZRPnd9SujE2gqvzxeEcMeWWGLFQU4GtZjmLxsMxLkM8hoLQgGQmpZchZZf9hbUPeFy8YtAAqVBGtUd5GxJB7WQyZgrCtP8k
  Share  3: SSS-2swZSJy24FKcSJihh7rGxtNreWr3AzHppe2e5tCxeufibRWPdVDJuWwsYdyiMpJd8sNLTRc21ymC9J2FdznTfvJjgGdrjfAEGd
  Share  4: SSS-2swZSgNK7x66xErTj5AjkASK5MSgWgr5t9vYpF4YpiMZbzumJx3sTGh9WsyuBgr3xfLJ77qNnmnahCnhrBa4tjBMagbZBPBC6K
</pre>
