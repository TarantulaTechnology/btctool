<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing a secret (which may be a Bitcoin private key or a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that individually the shares do not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme, or M of N secret sharing.
Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of 16, 32 or 64 bytes.
* Define ''L'' as the length of the secret, in bytes. For an ordinary Bitcoin private key, ''L'' = 32.
* Define ''M'' ≥ 1 as the minimum number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is an sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K''. <br /><!--
  --> Implementations may use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 0 to ''M''-2:
## split ''a''<sub>''i''</sub> into chunks of 32 bytes (the last chunk can be shorter);
## apply Hash<sub>''w''</sub> to each chunk, where ''w'' is the size of the chunk in bytes;
## let ''a''<sub>''i''+1</sub> be the concatenation of the results of the previous step.
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', x ≠ 0 (i.e. 1 ≤ ''x'' ≤ 255).
# The shares are the ordered pairs (''x'', ''y''(''x'')).

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

The encoding can optionally include a two-byte key identifier and the value of ''M''.  They enable detection of errors during secret recovery at the cost of disclosing information that could potentially assist an adversary.

# Construct a payload as follows:
#* Byte 0 is the ''prefix byte'', as enumerated in the table below.
#* Bytes 1 and 2 contain an optional key identifier:
#** zeros, if the user has requested that key identifier be omitted; or
#** Hash<sub>2</sub>(''K''), if it is not 0000; or
#** FFFF hexadecimal, if Hash<sub>2</sub>(''K'') = 0000.
#* Byte 3 has the value [''M'']·16 + ''x'' , where [''M''] is either ''M'' or 0.
#* The remaining bytes in the payload are the ''L'' bytes of ''y''(''x'').
# Encode the payload using Base58Check with an application/version byte as indicated in the table below.

{|
!rowspan="2"|Secret Size
!rowspan="2"|Application/<br/>Version Byte
!rowspan="2"|Secret Type
!colspan="2"|Prefix Byte
!rowspan="2"|Base58<br/>Length
|-
!Mainnet
!Testnet
|-
|128 bits
|align="center"|<code>0x3F</code>
|align="center"|seed
|align="center"|<code>0x3B</code>
|align="center"|<code>0x3C</code>
|align="center"|34
|-
|rowspan="3"|256 bits
|align="center" rowspan="3"|<code>0x73</code>
|align="center"|uncompressed private key
|align="center"|<code>0x70</code>
|align="center"|<code>0x74</code>
|align="center" rowspan="3"|56
|-
|align="center"|compressed private key
|align="center"|<code>0x72</code>
|align="center"|<code>0x76</code>
|-
|align="center"|seed
|align="center"|<code>0xFB</code>
|align="center"|<code>0xFC</code>
|-
|512 bits
|align="center"|<code>0x06</code>
|align="center"|seed
|align="center"|<code>0xBB</code>
|align="center"|<code>0xBC</code>
|align="center"|99
|}

Bits of the prefix byte indicate type of encoded content:
* bit 3: 0 for private key, 1 for BIP32 seed;
* bit 2: 0 for main network, 1 for test network;
* bit 1: in case of a private key, 0 means uncompressed and 1 means compressed.

== Motivation ==

A common technique for protecting Bitcoin private keys is to encrypt the private key with a password, such as using [https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki BIP38]. While this protects the key from anyone who cannot determine the password, it also has some significant drawbacks:

# The encryption is only as strong as the password chosen by the user. Human beings are notoriously bad at choosing strong random passwords, and even worse at remembering them.

# Once the key has been encrypted with a password the user is left with two things that he has to keep safe. If one of them is lost the key is lost.

Shamir's Secret Sharing scheme allows you to split any secret into N shares, and set a threshold of M (1 <= M <= N)  shares that allow you to recombine the secret. A classic example is to configure M=2 and N=3, meaning that you split a secret into 3 shares, and any 2 shares can recombine the secret. When compared to the aforementioned private key encrypted by a password, it fixes both drawbacks:

# There is no potentially weak human generated password.  

# If you lose any one of the three shares due to theft, flood, or fire, you can still recreate the secret by combining the remaining two shares. If an adversary obtains one of two required shares, then the adversary has no better alternative than to brute force the secret.

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== This is not Multi-Sig ===

Bitcoin supports two multi-signature schemes ([https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP11], [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16]), in which redeeming transaction outputs requires signatures by multiple private keys.

This specification is not a replacement for multi-sig transactions. Rather it provides a secure mechanism for storing and protecting private keys and [https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki BIP38] master seeds, which in turn can be used for multi-signature transactions.

== Rationale ==

It is anticipated that 15 shares will be enough for most applications of Shamir's Secret Sharing Scheme to Bitcoin private keys and BIP32 master seeds. Thus, ''M'' and ''x'' are allocated 4 bits each, and to minimise code complexity, GF(2<sup>8</sup>) is chosen as the underlying field.

The application/version bytes and prefix bytes were chosen to force the initial characters in the Base58Check encoding for keys to "SK" and BIP32 seeds to "SS", which can be taken as standing for "Share of a Key/Seed".  However, certain 512 bit testnet seed encodings can also begin with "ST".

The Hash<sub>2</sub>(''K'') and ''M'' fields are located at the beginning of the payload so that all shares for a given secret will share a common prefix and thus can be visually associated.

== Reference Implementation ==

NOTE: reference implementation and test vectors are not up to date yet.

[https://github.com/cetuscetus/btctool/blob/bip/bip-sss.py bip-sss.py]

This reference implementation is written with the aim of illustrating the algorithm and encoding scheme.  It is not optimised for any specific purpose nor does it follow any specific software development paradigm.

=== Test Vectors ===

A set of test vectors is in [https://github.com/cetuscetus/btctool/blob/bip/bip-test.txt bip-test.txt].  More can be generated with [https://github.com/cetuscetus/btctool/blob/bip/bip-sss.py bip-sss.py].  Below are a few examples.

* '''Uncompressed private key, mainnet, ''M'' = 2, compact form''' (first 3 shares)
** Secret: <code>ee642633bb066381cc22c289c30190ec11b967445a38110c8491702f34dcaf1b</code>
** Private key: <code>5KdGxvP4QWyAcMBaqaixTrksuLFSBaDCRUCv2sykzNBqzSJQmku</code>
** Share 1: <code>SKMaGkFbPWiyve22b3oBcBZSNbNWu9qzqfKZWuBgn7sCZgFsqizNq</code> (53 chars)
** Share 2: <code>SKMcsd7jgD5MJk2YSzNpyDnugi2hqcLghhPnbhvDbWECzNfkJNc53</code>
** Share 3: <code>SKMfG8ZUkKKT6VJDVDmpUjjNJMqtLE5csjaauxUhb9zo7XdoWDqzP</code>
* '''Compressed private key, testnet, ''M'' = 2, compact form''' (first 3 shares)
** Secret: <code>fa0487b457d96b820ac31d6f8a0e8efad79844219096783e3484cf09b24a516b</code>
** Private key: <code>cVxhkPaB89GWJn65M3RtsFK6wCG7sTcJ5LnW2ZMUcCU2zxr24iQ7</code>
** Share 1: <code>SLgoCtUFveresUizAcLqvhL3bwqQ7hudsSkUY1wG4vn2gfvcPgiXx</code> (53 chars)
** Share 2: <code>SLgqcW4h8bEeFgLRH2CQrWSc5KR5SbLX5nR8Q2VyDgjtrKNMpjc7m</code>
** Share 3: <code>SLgrwc4QY3P6qSPcrfzXEzq4kvekYMQhZLyk1Bcw73SfSG5hpnVf5</code>
* '''Uncompressed private key, mainnet, ''M'' = 2, long form''' (first 2 shares)
** Secret: <code>9074db560ac377aa7a9efa6c2ab8c32ac90ffeff251e28edcdf5b89a12ed235a</code>
** Private key: <code>5JuuXb7tQNk1Nmme7Nqs3Pe3o7iSECzdRDmEb5U8ekHazrTnB3u</code>
** Hash: <code>dcd3</code>
** Share 1: <code>SKFd7FtmvyZLH3VRLMUjdkpQRi5DBpYiEDWaGt2tigybUusNANSBpT76o</code> (57 chars)
** Share 2: <code>SKFd7Ftq4EgoevCaicMcCRrhgBP2wiqUE6hresfHN5gZqBAeqSVxUqjHE</code>
* '''128-bit seed, mainnet, ''M'' = 2, compact form''' (first 3 shares)
** Secret: <code>bd6b8f33bad1d3314f040a49aea3613e</code>
** Share 1: <code>SS9yu27afjaGGfCtGYrvojo8HmxhWHW</code> (31 chars)
** Share 2: <code>SS9zmdhsMcSm7YFzGnMxykYLnCc5hce</code>
** Share 3: <code>SSA5AKrXof6F6u1Ytv5rRWhiXaCZkBs</code>
