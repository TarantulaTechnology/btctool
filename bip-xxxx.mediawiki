<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>,
          Nikita Schmidt,
          Jan Møller,
	  Jérôme Rousselot
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing an arbitrary secret (for example, a Bitcoin private key, a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed or extended private key, or anything else) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that any smaller subset does not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme, or M of N secret sharing.
Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of bytes.
* Define ''L'' as the length of the secret, in bytes. For an ordinary Bitcoin private key in Wallet Import Format, ''L'' = 33 or 34.
* Define 1 ≤ ''N'' ≤ 16 as the total number of shares requested.
* Define 1 ≤ ''M'' ≤ N as the number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is a sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K'' or Hash<sub>2</sub>(''K''). <br /><!--
  --> Implementations may use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 1 to ''M''-1:
## let ''b''<sub>''i'',0</sub> := SHA-256(''a''<sub>''i''-1</sub> || 0),<br/>where || denotes concatenation and 0 is a zero byte
## for each ''j'' from 1 to (''L''-1) / 32: let ''b''<sub>''i'',''j''</sub> := SHA-256(''b''<sub>''i'',''j''-1</sub>)
## let ''a''<sub>''i''</sub> be the first ''L'' bytes of ''b''<sub>''i'',0</sub> || … || ''b''<sub>''i'',(''L''-1)/32</sub>
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', 1 ≤ ''x'' ≤ 16.
# The shares are the ordered pairs (''x'', ''y''(''x'')).
Note that although mathematically ''x'' can be any non-zero element of '''GF''', i.e. between 1 and 255, our chosen encoding limits it to the maximum of 16.

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

# Let ''ID'' be a unique identifier for this set of shares; either
#* two random bytes, or
#* Hash<sub>2</sub>(''K''),<br/>at the implementation's discretion.  Its purpose is to help identify which shares belong together.
# For each share (''x'', ''y''(''x'')), construct a payload as follows:
#* Byte 0 is the ''secret type byte'', as enumerated in the table below.
#* Bytes 1 and 2 contain ''ID''.
#* Byte 3 has the value (''M''-1)·16 + (''x''-1).
#* The remaining bytes in the payload are the ''L'' bytes of ''y''(''x'').
# Encode the payload using Base58Check with no application/version byte.

Values of the ''secret type byte'' are allocated as follows.
{|
!Value
!Type of secret
|-
|align="center"|1
|Octet string with application-specific interpretation
|-
|align="center"|2
|Any type of data for which a Base58Check encoding is specified<br/>(such as Bitcoin private key in Wallet Import Format)
|-
|align="center"|3
|BIP32 seed as a sequence of 16, 32 or 64 bytes
|}

Type 2 provides for a universal container for any data (usually Bitcoin-related) that are usually represented in Base58.

When sharing type 2 secrets, their encoded form before Base58Check is taken as the value of ''K'', including the
application/version byte but excluding the checksum.  Consider for example a private key, which is to be used with a
compressed public key:
<div align="center">''K'' = <code>0x80</code> &lt;private key bytes in big endian order&gt; <code>0x01</code>.</div>

== Motivation ==

The backup storage of Bitcoin private keys and [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds is of critical importance to users. Indeed, the loss of a bitcoin wallet means losing all bitcoins stored on the addresses managed by that wallet, if no backup was made. However, simply saving the private key on paper (cold storage) is not enough. What happens when this document is lost ? It may be password protected, for instance using [https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki BIP38]. But what if the user selected a weak password, for instance a date of birth, so that he is sure he can remember it ? This is very common, as described in [http://research.microsoft.com/pubs/74164/www2007.pdf large-scale-study-web-passwords]. Therefore, key stretching may not be secure enough against some dictionary attacks. If the backup is lost, then the funds can be lost as well. A backup in another location is the ideal solution to this problem. But trusting a third party with a private key also carries significant risk.

We suggest to use Shamir's Secret Sharing scheme, as it reduces the risks associated with the loss of one of the paper backups, and with entrusting a third party with the paper backup.

Shamir's Secret Sharing scheme allows the user to split any secret into N shares, and set a threshold of M (1 ≤ M ≤ N)  shares that allow the user to recombine the secret. A classic example is to configure M=2 and N=3, meaning that the user split a secret into 3 shares, and any 2 shares can recombine the secret. This secret can be encrypted by a password, although this is not required.

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== This is not Multi-Sig ===

Bitcoin supports two multi-signature schemes ([https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP11], [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16]), in which redeeming transaction outputs requires signatures by multiple private keys.

This specification is not a replacement for multi-sig transactions. Rather it provides a secure mechanism for storing and protecting private keys and [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds, which in turn can be used for multi-signature or classic transactions.

== Rationale ==

It is anticipated that 16 shares will be enough for most applications of Shamir's Secret Sharing Scheme. Thus, ''M'' and ''x'' are allocated 4 bits each.

The ''ID'' and ''M'' fields are located at the beginning of the payload so that all shares for a given secret will share a common prefix and thus can be visually associated.  It can be argued that their inclusion can assist an attacker.  However, this information is essential for secret recovery: the user must know which shares to combine and in what quantity.  If this is not contained in the shares, the user will need to find alternative means of recording this information out-of-band, for example, by writing it down next to each share or memorizing it.  This is inconvenient and/or risky for the user and/or helpful for the attacker in a similar way PINs and passwords are.  The point of Shamir's secret sharing, on the opposite, is to provide a safe, secure and convenient way to keep a secret without passwords.

No provision has been made to make ''ID'' and ''M'' optional.  This is to reduce implementation burden associated with the complex logic required to handle cases when either or both are omitted, particularly in applications with a focus on user interface.

A common practice is to use the application/version byte (AVB) to both identify the type of payload and force the initial character/s in the Base58Check encoding to a specific prefix, aiding visual recognition of different types of encoded data.  However, the latter is only possible with fixed length payloads.  To preserve both functions of the AVB, this specification proposes to effectively move it outside of the binary payload by attaching the 'SSS-' prefix to the Base58Check encoded string.

An earlier draft of this specification proposed GF(''P'') as the field, where ''P'' was a large prime number close to 2<sup>8''L''</sup>, specified individually for each possible value of ''L''.  In order to support arbitrary length secrets, the field was changed to GF(2<sup>8</sup>).

A timestamp field was discussed, which would be useful with BIP32 payloads as the key inception time point to optimize private key import into a wallet.  However, it has no general use in the secret sharing scheme and belongs rather to the shared data.  An encoding that contains inception time, e.g. as [https://bitcointalk.org/index.php?topic=258678.0 proposed by J.-P. Kogelman and W. Yager], can be used as a type 2 secret instead of the plain seed (type 3).

== Reference Implementation ==

[https://github.com/cetuscetus/btctool/blob/bip/bip-sss.py bip-sss.py]

This reference implementation is written with the aim of illustrating the algorithm and encoding scheme.  It is not optimized for any specific purpose nor does it follow any specific software development paradigm.

=== Test Vectors ===

A copy is in [https://github.com/cetuscetus/btctool/blob/bip/bip-test.txt bip-test.txt].

<pre>
Generic data: (empty)
2 of 2 encoding; share set ID 5df6; share length 14
  Share  1: SSS-EGCEhcC94d
  Share  2: SSS-EGCEpYoMeV

Generic data: 2a
2 of 3 encoding; share set ID ff12; share length 16
  Share  1: SSS-2UV2RrEUJTRk
  Share  2: SSS-2UV2SEgpvuRu
  Share  3: SSS-2UV2SmDVHSAg

Generic data: 0102030405
1 of 1 encoding; share set ID a26b; share length 21
  Share  1: SSS-8txqHtUghKJLrAF13

Generic data: 0102030405
5 of 8 encoding; share set ID a26b; share length 21
  Share  1: SSS-8txttSnh3TAKB7dCV
  Share  2: SSS-8txtzFWa68hUQ8Lky
  Share  3: SSS-8txu2FsNVj5HQR4as
  Share  4: SSS-8txu4kTYmcePqpd9x
  Share  5: SSS-8txuAR421JSp6Lo8g
  Share  6: SSS-8txuDudvrVBCLiSWm
  Share  7: SSS-8txuFu9y4du1vH4jq
  Share  8: SSS-8txuHKfcwJopauEjJ

Private key: 5KX5JknPztEdGp3HuHKWz1zKNtgbi6AYoR1tA4rGnUAwzSxzZyD
2 of 3 encoding; share set ID ba31; share length 59
  Share  1: SSS-bh6pjz49szVLo1WUEYywkaCqK4CGWhoHo2UvngPegtWqSbsRAM6BW5m
  Share  2: SSS-bh6pnrPJfoe8a6DaJAQrgPkYnjYjb9dPAzPpQDKipoTMQWZj6tm19fN
  Share  3: SSS-bh6pz3HGo6UsSNZzobdRUmDsJoazuXFuRnM1bWwVhsaJ2Hk6SsumHYW

Private key: L4FWwzuxPn4gU5z8oVBwErWFJrZGMVdSx6YiYZj3y3G1JBLkF3HT
4 of 4 encoding; share set ID 6ea2; share length 61
  Share  1: SSS-3MYty2enHnEGMW44rWCuoaDU2pDRN6i1yazfyLZ6xWYatH9GpfkHwa1vi
  Share  2: SSS-3MYtyyWR368SGTLVLgnohjnLAtrxjLp3TaTEbs4BiRiCpi84hmg3rBXUk
  Share  3: SSS-3MYtzUeuKS41AHXeVZ6Fj1nAp8bKrjADvgU4PErtzu9zLkkJLABd5RCaY
  Share  4: SSS-3MYu1DyyvF9qMMxKPAULR93XPUU5EkuTAeYwhzwR3MvEnQbd4UUcrxkPj

BIP32 seed: 83b9dae544cd7567c0e99d9e5a27588b
16 of 16 encoding; share set ID 975d; share length 36
  Share  1: SSS-KzMjeSbodoQt3yQskHRskTvgkNaso5BM
  Share  2: SSS-KzMjj8zq9FLGX7wanvBdRTEjdkEtMUq2
  Share  3: SSS-KzMjnFdFwMJmvZiGgYBL9vrMytAnnxUa
  Share  4: SSS-KzMjs6RUEQmsWfSJC56KEeu6aiV5eVGK
  Share  5: SSS-KzMjufcCcnfqffQ5AuLj1nu884qxenDk
  Share  6: SSS-KzMjz4anKdAkNG28D9HAy6hdSGZhZBkc
  Share  7: SSS-KzMk4LZLxzqyNv9WbPCuXXeZ7GP3v7Ju
  Share  8: SSS-KzMk5JeQrNihCtrfCJpdKQyyzNw3stsg
  Share  9: SSS-KzMkBgzUCuBgRrE35SXj937UrL8KqTCp
  Share 10: SSS-KzMkEHYpPjHbdtJuc6pczt11oQS4xYu2
  Share 11: SSS-KzMkG3KfDvdfpdu6d3uDvZBEDbfEr7j5
  Share 12: SSS-KzMkLdN5sdCYhcGMCf1YZ1P26G3dthyG
  Share 13: SSS-KzMkPsbpyAhQh2FxA5WLwiSo7HQcLKyE
  Share 14: SSS-KzMkTfveXG7zXQ8g99cHEAAsv7LUf83q
  Share 15: SSS-KzMkXbMSq5ZWf8v8UQhTYyJJBUhK4Kdr
  Share 16: SSS-KzMkb1hcUjc2ngmp18jXfWe7RhXeL6y9

BIP32 seed: c4011cbcbdd5ae7d866b7baeba6383735c11cb6ea46fad49e990b2a413aee2f0
3 of 6 encoding; share set ID 9f97; share length 58
  Share  1: SSS-BSeVvKiK98fARMnHGPTJP2GXa6DAK3R9wTWr27XFGiZFcQHdsGX9BG
  Share  2: SSS-BSeVxv6xpKssMa4tNtHM4mxJRB1KM4dx1CsWMtscywgsYub8YYbxjY
  Share  3: SSS-BSeVzbzoyLpDy6uifRz66CXMajoPH8siQDqh6bV3uPMRSS5VsdqcS1
  Share  4: SSS-BSeW2hYuTrvXG9krcTUp2cTzgSr5MYCB5uwznzPG18zvhhKsNjKkze
  Share  5: SSS-BSeW4bXZdYaTewS1AypoJNaeBsHTpoJ7MucjEvTCkFkCCK3U6a4tRb
  Share  6: SSS-BSeW7E8x6p3FXYkC56RjRFx1qNtxdi6hf2Lhcig8bxHSMwtvM85FD4

BIP32 seed: 5d1c618e26ccc9ec6f7fc09e36a1dec35a464b17f15bee924d1a17c6b041526a37591ddd320bfe683f5805511a6ce58bbbd9096e6b91fe1591960ed653be5089
2 of 4 encoding; share set ID 4d4b; share length 102
  Share  1: SSS-3pxEciXPAqz7zUxXDKdgP8SJTPbhFSv5STXYKSLQQKqsrqw8DZ3Ag6d9t72z16ang3CQthEpDShktZ8vPY1KkRbMNtqH95JdAN
  Share  2: SSS-3pxEd4t3bGWryP4DTF3hy2Aj2TDT9HshWwtFaFPneWMfaESN8LGhhpmdCJm8zcKFdPSe9sgDLejz2kxtrjZ5JdB8tRdtyb6PeF
  Share  3: SSS-3pxEdi7D4Z8HR3Dc7mBhACcKZq3a59AeTKHHV8pEGyFBBHCw2oJrx56RueSbf5W1JR7144VrNYJ9nfn9UQWWUNpJMDkJ9f5DJh
  Share  4: SSS-3pxEedyJBCh4jghSHCCEjuypXCoQsEKekZAERjmnZRkYKa94SL6yreF96tSfcC8NRgZaCZNyaLvM13azdUDUDHfufyTohLXqjd
</pre>
