<pre>
  BIP: xxxx
  Title: Shamir Sharing of Private Keys
  Author: Matt Whitlock <bip@mattwhitlock.name>
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing a Bitcoin private key into shares in a manner such that the key can be reconstituted from any sufficiently large subset of the shares but such that individually the shares do not reveal any information about the key. This method is commonly known as Shamir's Secret Sharing Scheme. Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define <code>uint256_t</code> as a data type whose value space is the set of all unsigned 256-bit integers.
* Define <code>uint256_t</code> ''K'' as the private key.
* Define ''M'' as the minimum number of shares needed to reconstitute the private key.
* Define <code>uint256_t</code> ''N'' as the order of the generator point in the [https://en.bitcoin.it/wiki/Secp256k1 secp256k1] elliptic curve.
* Define <code>SHA256</code>(''m'') as a function that:
*# accepts as an argument a <code>uint256_t</code> ''m'',
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of a message consisting of the 256-bit binary encoding of ''m'' in big-endian byte order,
*# interprets the resulting message digest as the 256-bit binary encoding of a <code>uint256_t</code> ''d'' in big-endian byte order,
*# returns ''d''.

=== Derivation of Shares from Private Key ===

# Let <code>uint256_t</code> ''a''<sub>0</sub> := ''K''.
# Let <code>uint256_t</code> ''a''<sub>''i''</sub> := <code>SHA256</code>(''a''<sub>''i''−1</sub>) for 1 ≤ ''i'' &lt; ''M''.
# Let <code>uint256_t</code> ''x''<sub>''j''</sub> := ''j'' + 1 for 0 ≤ ''j'' &lt; ''N''−1.
# Let <code>uint256_t</code> ''y''<sub>''j''</sub> := ''a''<sub>0</sub>·''x''<sub>''j''</sub><sup>0</sup> + ''a''<sub>1</sub>·''x''<sub>''j''</sub><sup>1</sup> + … + ''a''<sub>''M''−1</sub>·''x''<sub>''j''</sub><sup>''M''−1</sup> (mod ''N'') for 0 ≤ ''j'' &lt; ''N''−1.
# The shares are the ordered pairs (''x''<sub>''j''</sub>, ''y''<sub>''j''</sub>) for 0 ≤ ''j'' &lt; ''N''−1.

=== Reconstitution of Private Key from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''<sub>''i''</sub>) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let <code>uint256_t</code> ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (mod ''N'') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product (mod ''N'') of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let <code>uint256_t</code> ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (mod ''N'') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product (mod ''N'') of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let <code>uint256_t</code> ''a''<sub>0</sub> := ''y''<sub>0</sub>·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''<sub>1</sub>·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''<sub>''M''−1</sub>·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (mod ''N'').
# The private key is ''a''<sub>0</sub>.

=== Encoding of Shares ===

This encoding scheme is applicable to the first 256 shares: (''x''<sub>0</sub>, ''y''<sub>0</sub>) through (''x''<sub>255</sub>, ''y''<sub>255</sub>). Applications needing more than 256 shares must use some other encoding scheme.

# Construct a 34-byte payload as follows:
#* Byte 0 is <code>0xF6</code> if the private key is in compressed format; else, byte 0 is <code>0xF4</code>.
#* Byte 1 is ''j'' for 0 ≤ ''j'' &lt; 256.
#* Bytes 2–33 are the 256-bit binary encoding of ''y''<sub>''j''</sub> in big-endian byte order, for 0 ≤ ''j'' &lt; 256.
# Encode the payload using Base58Check with an application/version byte of <code>0x26</code>.

== Motivation ==

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== Comparison with Alternatives ===

Bitcoin supports [https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki a multi-signature scheme], in which redeeming transaction outputs requires signatures by multiple private keys. In theory this achieves the same objective as the application of Shamir's Secret Sharing Scheme to a single private key: namely, multiple pieces of information are required in order to spend the funds at an address, and any sufficiently large subset of the corpus of all such pieces of information suffices. Further, the multi-signature scheme has the advantage that the signatures can be computed independently at separate times and places. However, one critical disadvantage of the multi-signature scheme is the space it consumes in the block chain: all public keys in the corpus must be embedded in the scriptSig of every input that claims a multi-signature output. For this reason, "standard" multi-signature scriptSigs are presently limited to containing no more than three public keys. Even if this limitation were to be lifted, the multi-signature scheme would still yield rather large (and thus costly) scriptSigs. Another, lesser disadvantage of the multi-signature scheme is that it is more cumbersome for users to manage, as not only must users store the private keys, but they must also store a "redeem script."

In comparison to the multi-signature scheme, Shamir's Secret Sharing Scheme has the disadvantage that a sufficient number of shares must be brought together in one place at one time in order to reconstitute the private key that is needed for signing a transaction. However, it has several advantages:
* No new address format is used, so all first-generation Bitcoin infrastructure already supports it implicitly.
* Any number of shares can be generated and distributed without increasing the size of the scriptSig.
* Any subset size can be required for successful key reconstitution without increasing the size of the scriptSig and without increasing the number of signature verification operations necessary to validate the transaction.
* It can be extended to other secrets besides private keys, such as [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds.

=== Use with Multi-signature ===

Shamir's Secret Sharing Scheme can be used in conjunction with the multi-signature scheme mentioned above. As an example, consider a hypothetical organization that stores its operating funds at a 3-of-3 multi-signature address. Spending funds from this address requires signatures from the president, the chief financial officer, and the board of directors. Ideally, getting a signature from the board of directors should require the consent of a majority of the board, but if any single director has possession of the board's private key, then this "majority required" policy cannot be enforced cryptographically. However, if a distinct Shamir share, derived from the board's private key, is distributed to each director, then only a sufficiently large subset of the directors, working together, can reconstitute the board's private key and sign the transaction.

== Rationale ==

It is anticipated that 256 shares will be more than enough for most applications of Shamir's Secret Sharing Scheme to Bitcoin private keys. Thus, to reduce encoded share size, the encoding of ''j'' is restricted to one byte.

The application/version byte (<code>0x26</code>) and the prefix byte (<code>0xF6</code> or <code>0xF4</code>) were chosen to force the initial characters in the Base58Check encoding to "SS", which can be taken as standing for "Shamir Share."
* '''Compressed private key share''' (application/version = <code>0x26</code>, prefix = <code>0xF6</code>)
** Lower bound (''j'' = 0)
*** Value: <code>0x26F6000000000000000000000000000000000000000000000000000000000000000000</code>
*** Base58Check encoding: <code>SSSJ5cf1K6GpL4F6avjp9LvaqEgoHJoVYfGAz1gbGKfv1NZ6DvNKn</code>
** Upper bound (''j'' = 255)
*** Value: <code>0x26F6FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>
*** Base58Check encoding: <code>SSasiBpNDGRjU2m7MUpD396gKV7zw9DmGpho7a8wMp9fiet8n1199</code>
* '''Uncompressed private key share''' (application/version = <code>0x26</code>, prefix = <code>0xF4</code>)
** Lower bound (''j'' = 0)
*** Value: <code>0x26F4000000000000000000000000000000000000000000000000000000000000000000</code>
*** Base58Check encoding: <code>SS98pULHWjxz47D53pb2MkaPrjpPydxx6LNvitmu5LiQaothBsQ7i</code>
** Upper bound (''j'' = 255)
*** Value: <code>0x26F4FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>
*** Base58Check encoding: <code>SSHiT3VeQv7uC5j5pNfRFYkVLzFbdUPDpVpYrTEFAqCAJ6DjjxkTg</code>

== Reference Implementation ==

=== Test Vectors ===

* '''Compressed private key, ''M'' = 3''' (first 6 shares)
** Private key: <code>L4Shamir4KSghoE4uGhHJMFiG2ZrXRXydMgFvCUaCLgXQ88YKBMz</code>
** Share 0: <code>SSSKbWKpvHA2WRrGN7jEtZbSWCd8Jbk3NpBeaPzdGmHmVFHYJQY4H</code>
** Share 1: <code>SSSLUn6EgRoQK6CxirHqtbpjmmTEXpbRnWJ3FMbJnY5rzd3bzmKoZ</code>
** Share 2: <code>SSSNNMjoMehQk4SZXbQr6jZYkHRtGtYxxmD83hjUDtyGd1oic4Nmn</code>
** Share 3: <code>SSSRGFGWwwr3oLZ4nM6FWxosRkZ5XoceuavtySR7aqwzNRZknFJUk</code>
** Share 4: <code>SSSTDhWA1HPtohQeuQRUXHcPDUSa3kfp2t8SDSewtoifFqbbH4Dmc</code>
** Share 5: <code>SSSUEiSiXfLwm91KtmQX7hy67T6MpjiSLeojmiSy9nHHHFuAAwmKs</code>
* '''Uncompressed private key, ''M'' = 4''' (first 6 shares)
** Private key: <code>5KShamir9pqYHfa63F2r9iA44sK4iDdo2gtyAXHCSRwuCLdqgCv</code>
** Share 0: <code>SS9973ZqpD3pKAC9SnF4dQHKPA9Xp1niYXDRTKMAVcdJm4Ef4NF2Z</code>
** Share 1: <code>SS9BqymBhhzCwYzoUPeK1EkDMqsKoYrX3bN76VtQ5S9KQdxDnAXGN</code>
** Share 2: <code>SS9DVVQo3JarVNXu2c1SpQ66TNGt8z9WUtbMPNSXAz5Re5khtN3vR</code>
** Share 3: <code>SS9EhcXkmQ8NGq66ZgGqg5EGiYVeeG2pz6o9w2LqY3dST5GbogdWK</code>
** Share 4: <code>SS9J58KPGRknHN5t7aHSoT3Nnt3KQ7zJH1CS9fuwtyJXpJrmczbWF</code>
** Share 5: <code>SS9LNaSJaj3rUjYGy9AUZiY5XoGqit9hK73L2AWa4PhnmShRZ119a</code>
