<pre>
  BIP: xxxx
  Title: Shamir's Secret Sharing Scheme
  Author: Matt Whitlock <bip@mattwhitlock.name>
  Status: Draft
  Type: Informational
  Created: 28-03-2014
</pre>

== Abstract ==

A method is described for decomposing a secret (which may be a Bitcoin private key or a [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed) into shares in a manner such that the secret can be recovered from any sufficiently large subset of the shares but such that individually the shares do not reveal any information about the secret. This method is commonly known as Shamir's Secret Sharing Scheme. Additionally, an encoding methodology is proposed to standardize transmission and storage of shares.

== Copyright ==

This proposal is hereby placed in the public domain.

== Specification ==

* Define ''K'' as the secret, which is a sequence of 16, 32 or 64 bytes.
* Define ''L'' as the length of the secret, in bytes. For an ordinary Bitcoin private key, ''L'' = 32.
* Define ''M'' ≥ 1 as the minimum number of shares to be required when recovering the secret.
* Define '''GF''' as the finite field of order 2<sup>8</sup>, i.e. the field of equivalence classes of <!--
  --> polynomials whose coefficients belong to GF(2).  These polynomials are represented as bytes where <!--
  --> a more significant bit is a coefficient at a higher degree.  The modulus is the polynomial <!--
  --> ''x''<sup>8</sup>+''x''<sup>4</sup>+''x''<sup>3</sup>+''x''<sup>2</sup>+1, or 0x11d.
* Define '''GF'''<sup>''L''</sup> as the ''L''-dimensional vector space over '''GF''', whose elements are <!--
  --> represented as byte sequences of length ''L''.
* Define Hash<sub>''w''</sub>(''m'') as a function that:
*# accepts an argument ''m'', which is an sequence of bytes,
*# computes the [http://en.wikipedia.org/wiki/SHA-2 SHA-256] message digest of the SHA-256 message digest of ''m'',
*# and returns the first ''w'' bytes of the resulting digest.

=== Derivation of Shares from Secret ===

# Compute ''a''<sub>0</sub>, ''a''<sub>1</sub>, …, ''a''<sub>''M''-1</sub> &isin; '''GF'''<sup>''L''</sup> <!--
  --> such that ''a''<sub>0</sub> = ''K'' and all ''a''<sub>''j''</sub> are unpredictable to anyone who <!--
  --> does not know ''K''. <br /><!--
  --> Implementations can use random numbers, for example.  If a deterministic algorithm is desired so that <!--
  --> additional shares can be issued which are compatible with the previous shares for the same secret, then <!--
  --> <br/>for each ''i'' from 0 to ''M''-2:
## split ''a''<sub>''i''</sub> into chunks of 32 bytes (the last chunk can be shorter);
## apply Hash<sub>''w''</sub> to each chunk, where ''w'' is the size of the chunk in bytes;
## let ''a''<sub>''i''+1</sub> be the concatenation of the results of the previous step.
# Let ''y''(''x'') := ''a''<sub>0</sub>·''x''<sup>0</sup> + ''a''<sub>1</sub>·''x''<sup>1</sup> + … <!--
  --> + ''a''<sub>''M''−1</sub>·''x''<sup>''M''−1</sup> in '''GF'''<sup>''L''</sup> <!--
  --> for ''x'' &isin; '''GF''', x ≠ 0 (i.e. 1 ≤ ''x'' ≤ 255).
# The shares are the ordered pairs (''x'', ''y''(''x'')).

=== Recovery of Secret from Shares ===

# Let (''x''<sub>''i''</sub>, ''y''(''x''<sub>''i''</sub>)) be any ''M'' distinct shares for 0 ≤ ''i'' &lt; ''M''.
# Let ''n''<sub>''i''</sub> := ''x''<sub>0</sub> · … · ''x''<sub>''i''−1</sub> · ''x''<sub>''i''+1</sub> · … · ''x''<sub>''M''−1</sub> (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''n''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''d''<sub>''i''</sub> := (''x''<sub>0</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''i''−1</sub>−''x''<sub>''i''</sub>) · (''x''<sub>''i''+1</sub>−''x''<sub>''i''</sub>) · … · (''x''<sub>''M''−1</sub>−''x''<sub>''i''</sub>) (in '''GF''') for 0 ≤ ''i'' &lt; ''M''.
#* That is, ''d''<sub>''i''</sub> is the product in '''GF''' of all ''x''<sub>''j''</sub>−''x''<sub>''i''</sub> for 0 ≤ ''j'' &lt; ''M'' and ''j'' ≠ ''i''.
# Let ''a''<sub>0</sub> := ''y''(''x''<sub>0</sub>)·''n''<sub>0</sub>·''d''<sub>0</sub><sup>-1</sup> + ''y''(''x''<sub>1</sub>)·''n''<sub>1</sub>·''d''<sub>1</sub><sup>-1</sup> + … + ''y''(''x''<sub>''M''−1</sub>)·''n''<sub>''M''−1</sub>·''d''<sub>''M''−1</sub><sup>-1</sup> (in '''GF'''<sup>''L''</sup>).
# The secret is ''a''<sub>0</sub>.

=== Encoding of Shares ===

This encoding scheme is applicable to the first 256 shares: (''x''<sub>0</sub>, ''y''<sub>0</sub>) through (''x''<sub>255</sub>, ''y''<sub>255</sub>). Applications needing more than 256 shares must use some other encoding scheme.

# Construct a payload as follows:
#* Byte 0 is the ''prefix byte'', as enumerated in the table below.
#* Bytes 1 and 2 are the 16-bit binary encoding of Hash<sub>16</sub>(''K'') in big-endian byte order.
#* Byte 3 has the value ''M'' − 1.
#* Byte 4 is ''j'' for 0 ≤ ''j'' &lt; 256.
#* The remaining bytes in the payload are the ''L''-bit binary encoding of ''y''<sub>''j''</sub> in big-endian byte order, for 0 ≤ ''j'' &lt; 256.
# At the user's option, delete bytes 1 through 3, thereby reducing the length of the payload by 3 bytes. These bytes enable the detection of errors during secret recovery at the cost of disclosing information that could potentially assist an adversary.
# Encode the payload using Base58Check with an application/version byte as indicated in the table below.

{|
!Secret Type
!Network
!''L''
!Hash<sub>16</sub>(''K'')<br/>and ''M'' − 1
!Application/<br/>Version Byte
!Prefix Byte
|-
|rowspan="4"|Uncompressed private key
|align="center" rowspan="2"|Mainnet
|align="right" rowspan="2"|256
|align="center"|Present
|align="center"|<code>0x1A</code>
|align="center"|<code>0x46</code>
|-
|align="center"|Omitted
|align="center"|<code>0x26</code>
|align="center"|<code>0xF4</code>
|-
|align="center" rowspan="2"|Testnet
|align="right" rowspan="2"|256
|align="center"|Present
|align="center"|<code>0x1B</code>
|align="center"|<code>0x4F</code>
|-
|align="center"|Omitted
|align="center"|<code>0x28</code>
|align="center"|<code>0x7C</code>
|-
|rowspan="4"|Compressed private key
|align="center" rowspan="2"|Mainnet
|align="right" rowspan="2"|256
|align="center"|Present
|align="center"|<code>0x1A</code>
|align="center"|<code>0x47</code>
|-
|align="center"|Omitted
|align="center"|<code>0x26</code>
|align="center"|<code>0xF6</code>
|-
|align="center" rowspan="2"|Testnet
|align="right" rowspan="2"|256
|align="center"|Present
|align="center"|<code>0x1B</code>
|align="center"|<code>0x50</code>
|-
|align="center"|Omitted
|align="center"|<code>0x28</code>
|align="center"|<code>0x7E</code>
|-
|rowspan="12"| [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seed
|align="center" rowspan="6"|Mainnet
|align="right" rowspan="2"|128
|align="center"|Present
|align="center"|<code>0x0E</code>
|align="center"|<code>0x53</code>
|-
|align="center"|Omitted
|align="center"|<code>0x15</code>
|align="center"|<code>0x3D</code>
|-
|align="right" rowspan="2"|256
|align="center"|Present
|align="center"|<code>0x1A</code>
|align="center"|<code>0x49</code>
|-
|align="center"|Omitted
|align="center"|<code>0x26</code>
|align="center"|<code>0xF8</code>
|-
|align="right" rowspan="2"|512
|align="center"|Present
|align="center"|<code>0x58</code>
|align="center"|<code>0x7E</code>
|-
|align="center"|Omitted
|align="center"|<code>0x83</code>
|align="center"|<code>0x33</code>
|-
|align="center" rowspan="6"|Testnet
|align="right" rowspan="2"|128
|align="center"|Present
|align="center"|<code>0x0E</code>
|align="center"|<code>0xE3</code>
|-
|align="center"|Omitted
|align="center"|<code>0x16</code>
|align="center"|<code>0x12</code>
|-
|align="right" rowspan="2"|256
|align="center"|Present
|align="center"|<code>0x1B</code>
|align="center"|<code>0x51</code>
|-
|align="center"|Omitted
|align="center"|<code>0x28</code>
|align="center"|<code>0x80</code>
|-
|align="right" rowspan="2"|512
|align="center"|Present
|align="center"|<code>0x5B</code>
|align="center"|<code>0xF9</code>
|-
|align="center"|Omitted
|align="center"|<code>0x88</code>
|align="center"|<code>0x5B</code>
|}

== Motivation ==

The idea of applying Shamir's Secret Sharing Scheme to Bitcoin private keys is frequently discussed within the Bitcoin community, but there has previously existed no technical recommendation for how to generate such shares or how to encode such shares for transmission and storage. This informational BIP seeks to standardize a method and encoding scheme to enable interoperability between multiple wallet implementations that may support Shamir's Secret Sharing functionality.

=== Comparison with Alternatives ===

Bitcoin supports [https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki a multi-signature scheme], in which redeeming transaction outputs requires signatures by multiple private keys. In theory this achieves the same objective as the application of Shamir's Secret Sharing Scheme to a single private key: namely, multiple pieces of information are required in order to spend the funds at an address, and any sufficiently large subset of the corpus of all such pieces of information suffices. Further, the multi-signature scheme has the advantage that the signatures can be computed independently at separate times and places. However, one critical disadvantage of the multi-signature scheme is the space it consumes in the block chain: all public keys in the corpus must be embedded in the scriptSig of every input that claims a multi-signature output. For this reason, "standard" multi-signature scriptSigs are presently limited to containing no more than three public keys. Even if this limitation were to be lifted, the multi-signature scheme would still yield rather large (and thus costly) scriptSigs. Another, lesser disadvantage of the multi-signature scheme is that it is more cumbersome for users to manage, as not only must users store the private keys, but they must also store a "redeem script."

In comparison to the multi-signature scheme, Shamir's Secret Sharing Scheme has the disadvantage that a sufficient number of shares must be brought together in one place at one time in order to recover the private key that is needed for signing a transaction. However, it has several advantages:
* No new address format is used, so all first-generation Bitcoin infrastructure already supports it implicitly.
* Any number of shares can be generated and distributed without increasing the size of the scriptSig.
* Any subset size can be required for successful key recovery without increasing the size of the scriptSig and without increasing the number of signature verification operations necessary to validate the transaction.
* It can be extended to other secrets besides private keys, such as [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] master seeds.

=== Use with Multi-signature ===

Shamir's Secret Sharing Scheme can be used in conjunction with the multi-signature scheme mentioned above. As an example, consider a hypothetical organization that stores its operating funds at a 3-of-3 multi-signature address. Spending funds from this address requires signatures from the president, the chief financial officer, and the board of directors. Ideally, getting a signature from the board of directors should require the consent of a majority of the board, but if any single director has possession of the board's private key, then this "majority required" policy cannot be enforced cryptographically. However, if a distinct Shamir share, derived from the board's private key, is distributed to each director, then only a sufficiently large subset of the directors, working together, can recover the board's private key and sign the transaction.

== Rationale ==

It is anticipated that 256 shares will be more than enough for most applications of Shamir's Secret Sharing Scheme to Bitcoin private keys and BIP32 master seeds. Thus, to reduce encoded share size, the encodings of ''j'' and ''M'' − 1 are restricted to one byte each.

The application/version bytes and prefix bytes were chosen to force the initial characters in the Base58Check encoding for mainnet keys/seeds to "SS", which can be taken as standing for "Shamir Share." Testnet keys/seeds have a prefix of "TS" to distinguish them visually.

The Hash<sub>16</sub>(''K'') and ''M'' − 1 fields are located at the beginning of the payload so that all shares for a given secret will share a common prefix and thus can be visually associated.

== Reference Implementation ==

=== Test Vectors ===

* '''Uncompressed private key, ''M'' = 2, optional bytes present''' (first 3 shares)
** Private key: <code>5KShamir9pqYHfa63F2r9iA44sK4iDdo2gtyAXHCSRwuCLdqgCv</code>
** Share 0: <code>SS5vaKvu62Wpu6cH8UTZYatPRcmhFuEK2e6qgD1R9kAWvRUE7ep5pRXw4</code>
** Share 1: <code>SS5vaKvvKU2bLjj68AwChTJLhFgobdznDUY9yGLx1oHGzNLsUGUjHPw6H</code>
** Share 2: <code>SS5vaKvyVeibEQhKo6YfS2csatZEY9gN22dB7CU7wxeBkDDAqGGYiLdFC</code>
* '''Uncompressed private key, ''M'' = 3, optional bytes omitted''' (first 3 shares)
** Private key: <code>5KShamir9pqYHfa63F2r9iA44sK4iDdo2gtyAXHCSRwuCLdqgCv</code>
** Share 0: <code>SS99vNs8gWGcGXYn8BrskaGSLR89EgmFaVz5WvbCSWfQG8G7nxKay</code>
** Share 1: <code>SS9BiCxZqLH39Qw7EEa8VvBKeWhz2sjPfNZktfiymU9QLES8k4QFF</code>
** Share 2: <code>SS9DsdSSnxDDH6Fty4pFZjRPcBW5EdikGneCcCsSbmNJszwrikuvu</code>
* '''Compressed private key, ''M'' = 3, optional bytes present''' (first 3 shares)
** Private key: <code>L4Shamir4KSghoE4uGhHJMFiG2ZrXRXydMgFvCUaCLgXQ88YKBMz</code>
** Share 0: <code>SSPid9bvrTGY96qyBqdVVPmZbvAcJseu2jYmpwiAK73zXW3shaG38VXcB</code>
** Share 1: <code>SSPid9byzK7X6YYiThiBE1vdsWgfrzqU7R3uGvvNw49jwPoofKVDupsSR</code>
** Share 2: <code>SSPid9c1cnMqpknQ7rUXJ3b6g5DindFLssqP9J2CkcuuvjSGQpKXD7ig9</code>
* '''Compressed private key, ''M'' = 2, optional bytes omitted''' (first 3 shares)
** Private key: <code>L4Shamir4KSghoE4uGhHJMFiG2ZrXRXydMgFvCUaCLgXQ88YKBMz</code>
** Share 0: <code>SSSKHFer2Q7Lzq2CwnuHhmWGeD4hezAKHGMYu24wswFStEN9hmLQK</code>
** Share 1: <code>SSSLni3MRdJqLoom1tz7vv6CwXa5yZSWQwA5aLBm3sDGeaw7b4Q6M</code>
** Share 2: <code>SSSNJARrprWKgnbK614xA4g9Er5UJ8ihYbxcFeJaDoB6QwW1WjS3s</code>
